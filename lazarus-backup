#!/bin/bash

# --- –ù–ê–°–¢–†–û–ô–ö–ò ---
VERSION="4.12.0-features"
SCRIPT_NAME="lazarus"
INSTALL_DIR="/opt/lazarus-backup"
BACKUP_DIR="$INSTALL_DIR/backup"
CONFIG_FILE="$INSTALL_DIR/config.env"
SYMLINK_PATH="/usr/local/bin/$SCRIPT_NAME"
REMOTE_URL="https://raw.githubusercontent.com/UnderGut/LAZARUS-Backup-Manager/main/lazarus-backup"

# --- –ö–õ–Æ–ß–ï–í–´–ï –°–õ–û–í–ê –î–õ–Ø –ü–û–ò–°–ö–ê ---
KEYWORDS=("remnawave" "telegram-shop" "shop-bot" "shopbot")

# --- –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ---
BOT_PATH=""
BOT_TOKEN=""
CHAT_ID=""
TG_MESSAGE_THREAD_ID=""
DB_USER="postgres"
IGNORE_MISMATCH="false"
EXCLUDE_DIRS=""
MAX_FILE_SIZE_MB="1"

# –ü–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª–∏ –æ—Ç–ø—Ä–∞–≤–∫–∏
SEND_TO_TELEGRAM="true"
SEND_TO_REMOTE="true"

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ä–æ—Ç–∞—Ü–∏–∏ (–ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É)
MAX_BACKUPS_COUNT="100"

# –£–¥–∞–ª—è—Ç—å —Å—Ç–∞—Ä—ã–µ –±—ç–∫–∞–ø—ã: "time" –∏–ª–∏ "count" (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é time)
DELETE_MODE="time"
# –°—Ä–æ–∫ —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –¥–Ω—è—Ö –ø—Ä–∏ —Ä–µ–∂–∏–º–µ time (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 7 –¥–Ω–µ–π)
RETENTION_DAYS="7"

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞
REMOTE_STORAGE_TYPE="off" # off, ftp, webdav
REMOTE_STORAGE_URL=""
REMOTE_STORAGE_USER=""
REMOTE_STORAGE_PASS=""
REMOTE_UPLOAD_STATUS_TEXT=""

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
BACKUP_PASSWORD=""

# –ó–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
BOT_CONTAINER_NAME="" 
DB_CONTAINER_NAME=""
DEFAULT_BOT_PATH="/opt/private-remnawave-telegram-shop-bot"
DEFAULT_DB_NAME="remnawave-telegram-shop-db"
DB_VOLUME_NAME="remnawave-telegram-shop-db-data"
DB_SERVICE_NAME="db" 

# –°—Ç–∞—Ç—É—Å—ã —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–π
SCHEDULE_FULL="–í—ã–∫–ª"
SCHEDULE_DB="–í—ã–∫–ª"
SCHEDULE_FILES="–í—ã–∫–ª"

# –§–ª–∞–≥ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞
IS_INTERACTIVE=true
if [[ ! -t 0 ]]; then IS_INTERACTIVE=false; fi

# –ê–≤—Ç–æ-–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –¥–ª—è –Ω–µ–∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, cron --yes)
AUTO_CONFIRM="false"

# –õ–æ–≥-—Ñ–∞–π–ª –¥–ª—è –ø–æ–¥—Ä–æ–±–Ω—ã—Ö –ª–æ–≥–æ–≤
LOG_FILE="/var/log/lazarus_backup.log"
LOCK_FILE="/var/run/lazarus.lock"
TEMP_DIRS=()

# –¶–≤–µ—Ç–∞
if [[ -t 0 ]]; then
    RED=$'\e[31m'; GREEN=$'\e[32m'; YELLOW=$'\e[33m'; GRAY=$'\e[90m'; CYAN=$'\e[36m'; MAGENTA=$'\e[35m'; RESET=$'\e[0m'; BOLD=$'\e[1m'
else
    RED=""; GREEN=""; YELLOW=""; GRAY=""; CYAN=""; MAGENTA=""; RESET=""; BOLD=""
fi

# --- SYSTEM & CLEANUP ---

cleanup() {
    local exit_code=$?
    # Remove lock file if we own it
    if [[ -f "$LOCK_FILE" ]]; then
        local lock_pid=$(cat "$LOCK_FILE" 2>/dev/null)
        if [[ "$lock_pid" == "$$" ]]; then
            rm -f "$LOCK_FILE"
        fi
    fi
    
    # Remove temp dirs
    for dir in "${TEMP_DIRS[@]}"; do
        if [[ -d "$dir" ]]; then rm -rf "$dir"; fi
    done
    
    exit "$exit_code"
}

trap cleanup EXIT INT TERM

acquire_lock() {
    # Only acquire lock for non-interactive backup commands
    if [[ "$IS_INTERACTIVE" == "true" ]]; then return 0; fi

    if [[ -f "$LOCK_FILE" ]]; then
        local lock_pid=$(cat "$LOCK_FILE" 2>/dev/null)
        if [[ -n "$lock_pid" ]] && kill -0 "$lock_pid" 2>/dev/null; then
            log_message "ERROR" "Concurrent execution attempt blocked (PID: $lock_pid is running)"
            echo "Lazarus is already running (PID: $lock_pid). Exiting." >&2
            exit 1
        else
            # Stale lock
            echo "$$" > "$LOCK_FILE"
        fi
    else
        # Check if we can write to lock file (might not be root)
        if touch "$LOCK_FILE" 2>/dev/null; then
            echo "$$" > "$LOCK_FILE"
        else
            # Fallback to tmp if /var/run is not writable
            LOCK_FILE="/tmp/lazarus.lock"
            echo "$$" > "$LOCK_FILE"
        fi
    fi
}

# --- –§–£–ù–ö–¶–ò–ò –ò–ù–¢–ï–†–§–ï–ô–°–ê ---

escape_markdown_v2() {
    echo "$1" | sed -e 's/\\/\\\\/g' -e 's/_/\\_/g' -e 's/\[/\\[/g' -e 's/\]/\\]/g' \
        -e 's/(/\\(/g' -e 's/)/\\)/g' -e 's/~/\~/g' -e 's/`/\\`/g' -e 's/>/\\>/g' \
        -e 's/#/\\#/g' -e 's/+/\\+/g' -e 's/-/\\-/g' -e 's/=/\\=/g' -e 's/|/\\|/g' \
        -e 's/{/\\{/g' -e 's/}/\\}/g' -e 's/\./\\./g' -e 's/!/\!/g'
}

send_telegram_notification() {
    local msg="$1"
    if [[ "$SEND_TO_TELEGRAM" == "true" && -n "$BOT_TOKEN" && -n "$CHAT_ID" ]]; then
        if command -v curl >/dev/null 2>&1; then
            local escaped_msg
            escaped_msg=$(escape_markdown_v2 "$msg")
            local thread_param=""
            [[ -n "$TG_MESSAGE_THREAD_ID" ]] && thread_param="-d message_thread_id=$TG_MESSAGE_THREAD_ID"
            
            curl -s -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" \
                -d chat_id="$CHAT_ID" \
                -d parse_mode="MarkdownV2" \
                -d text="üö® *Lazarus Error* üö®%0A%0A${escaped_msg}" \
                $thread_param >/dev/null 2>&1 || true
        fi
    fi
}

print_message() {
    local type="$1"; local message="$2"; local color_code="$RESET"
    case "$type" in
        "INFO") color_code="$GRAY" ;;
        "SUCCESS") color_code="$GREEN" ;;
        "WARN") color_code="$YELLOW" ;;
        "ERROR") color_code="$RED" ;;
        "ACTION") color_code="$CYAN" ;;
    esac
    echo -e "${color_code}[$type]${RESET} $message"

    if [[ "$type" == "ERROR" ]]; then
        send_telegram_notification "$message"
    fi
}

log_message() {
    # Level, Message
    local level="$1"; local message="$2"
    # Ensure log dir exists and file is writable
    local logdir
    logdir=$(dirname "$LOG_FILE")
    if [[ ! -d "$logdir" ]]; then mkdir -p "$logdir" 2>/dev/null || true; fi
    if [[ ! -f "$LOG_FILE" ]]; then touch "$LOG_FILE" 2>/dev/null || true; fi
    local ts
    ts=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$ts] [$level] $message" >> "$LOG_FILE" 2>/dev/null || true
}

rotate_internal_log() {
    # Rotate log if > 10MB
    local MAX_LOG_SIZE=$((10 * 1024 * 1024))
    if [[ -f "$LOG_FILE" ]]; then
        local size
        size=$(stat -c%s "$LOG_FILE" 2>/dev/null || echo 0)
        if [[ "$size" -gt "$MAX_LOG_SIZE" ]]; then
            mv "$LOG_FILE" "${LOG_FILE}.old"
            echo "Log rotated on $(date)" > "$LOG_FILE"
        fi
    fi
}

check_dependencies() {
    local deps=("tar" "gzip" "openssl" "docker" "find" "du" "date")
    local missing=()
    
    # Check for curl OR wget
    if ! command -v curl >/dev/null 2>&1 && ! command -v wget >/dev/null 2>&1; then
        missing+=("curl (or wget)")
    fi

    for cmd in "${deps[@]}"; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing+=("$cmd")
        fi
    done
    
    # Check for docker compose (v2)
    if command -v docker >/dev/null 2>&1; then
        if ! docker compose version >/dev/null 2>&1; then
             echo -e "${RED}[ERROR]${RESET} 'docker compose' plugin is required but not found."
             echo -e "${CYAN}[ACTION]${RESET} Please install docker-compose-plugin (v2)."
             exit 1
        fi
    fi

    if [[ ${#missing[@]} -gt 0 ]]; then
        echo -e "${RED}[ERROR]${RESET} Missing dependencies: ${missing[*]}"
        echo -e "${CYAN}[ACTION]${RESET} Please install them (e.g., apt install ${missing[*]})"
        exit 1
    fi
}

# --- –°–ò–°–¢–ï–ú–ê –û–ë–ù–û–í–õ–ï–ù–ò–Ø ---

check_for_updates() {
    clear
    echo -e "${CYAN}–ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π...${RESET}"
    
    local REMOTE_CONTENT
    if command -v curl >/dev/null 2>&1; then
        REMOTE_CONTENT=$(curl -sL "$REMOTE_URL")
    elif command -v wget >/dev/null 2>&1; then
        REMOTE_CONTENT=$(wget -qO- "$REMOTE_URL")
    else
        print_message "ERROR" "–ù–µ—Ç curl –∏–ª–∏ wget –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π."
        read -erp "Enter..." dummy; return
    fi

    local REMOTE_VERSION=$(echo "$REMOTE_CONTENT" | grep '^VERSION=' | head -1 | cut -d'"' -f2)

    if [[ -z "$REMOTE_VERSION" ]]; then
        print_message "ERROR" "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–µ—Ä—Å–∏–∏."
        read -erp "Enter..." dummy; return
    fi

    local V_LOCAL=$(echo "$VERSION" | cut -d'-' -f1)
    local V_REMOTE=$(echo "$REMOTE_VERSION" | cut -d'-' -f1)

    echo -e "–¢–µ–∫—É—â–∞—è –≤–µ—Ä—Å–∏—è: ${BOLD}$VERSION${RESET}"
    echo -e "–ê–∫—Ç—É–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è: ${BOLD}$REMOTE_VERSION${RESET}"
    echo ""

    if [[ "$VERSION" == "$REMOTE_VERSION" ]]; then
        print_message "SUCCESS" "–£ –≤–∞—Å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –ø–æ—Å–ª–µ–¥–Ω—è—è –≤–µ—Ä—Å–∏—è."
        read -erp "Enter..." dummy
        return
    fi

    local IS_UPGRADE=false
    if [[ "$(printf '%s\n' "$V_LOCAL" "$V_REMOTE" | sort -V | head -n1)" == "$V_LOCAL" && "$V_LOCAL" != "$V_REMOTE" ]]; then
        IS_UPGRADE=true
    fi

    if [[ "$IS_UPGRADE" == "true" ]]; then
        print_message "WARN" "–î–æ—Å—Ç—É–ø–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ!"
        read -erp "–û–±–Ω–æ–≤–∏—Ç—å —Å–∫—Ä–∏–ø—Ç —Å–µ–π—á–∞—Å? (y/N): " choice
        if [[ "$choice" =~ ^[Yy]$ ]]; then
            perform_update "$REMOTE_CONTENT"
        else
            print_message "INFO" "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ."
            read -erp "Enter..." dummy
        fi
    else
        echo -e "${YELLOW}‚ö†Ô∏è –í–Ω–∏–º–∞–Ω–∏–µ: –í–µ—Ä—Å–∏—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ —Å—Ç–∞—Ä–µ–µ –∏–ª–∏ —Ç–∞–∫–∞—è –∂–µ.${RESET}"
        read -erp "–í—Å–µ —Ä–∞–≤–Ω–æ –∑–∞–≥—Ä—É–∑–∏—Ç—å –≤–µ—Ä—Å–∏—é —Å —Å–µ—Ä–≤–µ—Ä–∞? (y/N): " choice
        if [[ "$choice" =~ ^[Yy]$ ]]; then
            perform_update "$REMOTE_CONTENT"
        else
            print_message "INFO" "–û—Ç–º–µ–Ω–µ–Ω–æ."
            read -erp "Enter..." dummy
        fi
    fi
}

perform_update() {
    local CONTENT="$1"
    if echo "$CONTENT" | head -n 1 | grep -q "^#!/bin/bash"; then
        echo "$CONTENT" > "$INSTALL_DIR/$SCRIPT_NAME"
        chmod +x "$INSTALL_DIR/$SCRIPT_NAME"
        print_message "SUCCESS" "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ! –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫..."
        sleep 1
        exec "$INSTALL_DIR/$SCRIPT_NAME"
    else
        print_message "ERROR" "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è. –û—Ç–º–µ–Ω–∞."
        read -erp "Enter..." dummy
    fi
}

# --- –°–ò–°–¢–ï–ú–ê –£–°–¢–ê–ù–û–í–ö–ò ---

install_script() {
    if [[ "$EUID" -ne 0 ]]; then
        echo -e "${RED}–û—à–∏–±–∫–∞: –ó–∞–ø—É—Å—Ç–∏—Ç–µ —Å–∫—Ä–∏–ø—Ç —Å –ø—Ä–∞–≤–∞–º–∏ root (sudo)!${RESET}"
        exit 1
    fi

    local CURRENT_SCRIPT_PATH=$(realpath "$0" 2>/dev/null)
    local INSTALLED_SCRIPT_PATH="$INSTALL_DIR/$SCRIPT_NAME"

    if [[ "$CURRENT_SCRIPT_PATH" == "$INSTALLED_SCRIPT_PATH" ]]; then
        return
    fi

    echo -e "${CYAN}--- –£–°–¢–ê–ù–û–í–ö–ê LAZARUS BACKUP ---${RESET}"
    if [[ ! -d "$INSTALL_DIR" ]]; then
        mkdir -p "$INSTALL_DIR"
        print_message "SUCCESS" "–°–æ–∑–¥–∞–Ω–∞ –ø–∞–ø–∫–∞: $INSTALL_DIR"
    fi

    local DOWNLOAD_SUCCESS=false
    local TEMP_FILE="/tmp/lazarus_install_tmp"

    if [[ -f "$0" && "$0" != "bash" && "$0" != "/dev/fd/"* ]]; then
        cp "$(realpath "$0")" "$INSTALLED_SCRIPT_PATH"
        DOWNLOAD_SUCCESS=true
    else
        print_message "INFO" "–ó–∞–≥—Ä—É–∑–∫–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–π –≤–µ—Ä—Å–∏–∏..."
        if command -v curl >/dev/null 2>&1; then
            curl -sL "$REMOTE_URL" -o "$TEMP_FILE"
        elif command -v wget >/dev/null 2>&1; then
            wget -qO "$TEMP_FILE" "$REMOTE_URL"
        else
            print_message "ERROR" "–î–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –Ω—É–∂–µ–Ω curl –∏–ª–∏ wget!"
            exit 1
        fi

        if [[ -f "$TEMP_FILE" ]]; then
            if head -n 1 "$TEMP_FILE" | grep -q "^#!/bin/bash"; then
                mv "$TEMP_FILE" "$INSTALLED_SCRIPT_PATH"
                DOWNLOAD_SUCCESS=true
            else
                print_message "ERROR" "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏! –°–µ—Ä–≤–µ—Ä –≤–µ—Ä–Ω—É–ª –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–∞–π–ª."
                rm -f "$TEMP_FILE"
                exit 1
            fi
        else
            print_message "ERROR" "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å —Ñ–∞–π–ª."
            exit 1
        fi
    fi

    if [[ "$DOWNLOAD_SUCCESS" == "true" ]]; then
        chmod +x "$INSTALLED_SCRIPT_PATH"
        if [[ -L "$SYMLINK_PATH" || -f "$SYMLINK_PATH" ]]; then rm -f "$SYMLINK_PATH"; fi
        ln -s "$INSTALLED_SCRIPT_PATH" "$SYMLINK_PATH"
        
        print_message "SUCCESS" "–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ó–∞–ø—É—Å–∫..."
        echo ""
        exec "$INSTALLED_SCRIPT_PATH"
        exit 0
    fi
}

# --- –Ø–î–†–û –ò–ù–¢–ï–õ–õ–ï–ö–¢–£–ê–õ–¨–ù–û–ì–û –ü–û–ò–°–ö–ê ---

scan_system_for_bot() {
    FOUND_PATH=""; FOUND_BOT=""; FOUND_DB=""
    local running_containers=$(docker ps --format '{{.Names}}|{{.Image}}')
    
    for container in $running_containers; do
        local c_name=$(echo "$container" | cut -d'|' -f1)
        local c_image=$(echo "$container" | cut -d'|' -f2)
        
        if [[ "$c_image" == *"remnawave/backend"* ]]; then continue; fi
        if [[ "$c_image" == *"remnawave/subscription-page"* ]]; then continue; fi
        if [[ "$c_name" == "remnawave" ]]; then continue; fi
        if [[ "$c_name" == "remnawave-db" ]]; then continue; fi 
        if [[ "$c_name" == "remnawave-redis" ]]; then continue; fi

        for key in "${KEYWORDS[@]}"; do
            if [[ "$c_image" == *"$key"* ]]; then
                FOUND_BOT="$c_name"
                local work_dir=$(docker inspect --format '{{ index .Config.Labels "com.docker.compose.project.working_dir" }}' "$c_name")
                if [[ -n "$work_dir" && -d "$work_dir" ]]; then FOUND_PATH="$work_dir"; fi
                break 2
            fi
        done
    done

    if [[ -z "$FOUND_PATH" ]]; then
        local search_dirs=("/opt" "/home" "/root")
        local compose_files=$(find "${search_dirs[@]}" -maxdepth 4 -name "docker-compose.yml" -o -name "compose.yaml" 2>/dev/null)
        for file in $compose_files; do
            if grep -q "remnawave/backend" "$file"; then continue; fi
            if grep -qE "image:.*($(IFS="|"; echo "${KEYWORDS[*]}"))" "$file" || grep -qE "container_name:.*($(IFS="|"; echo "${KEYWORDS[*]}"))" "$file"; then
                FOUND_PATH=$(dirname "$file")
                FOUND_BOT=$(grep "container_name:" "$file" | head -1 | awk '{print $2}' | tr -d '"' | tr -d "'")
                break
            fi
        done
    fi

    if [[ -n "$FOUND_PATH" ]]; then
        if cd "$FOUND_PATH" 2>/dev/null; then
            local db_services=("db" "postgres" "database" "postgresql")
            for svc in "${db_services[@]}"; do
                local db_c=$(docker compose ps -a --format '{{.Name}}' "$svc" 2>/dev/null)
                if [[ -n "$db_c" && "$db_c" != "remnawave-db" ]]; then FOUND_DB="$db_c"; break; fi
            done
            cd - >/dev/null
        fi
    fi
}

# --- –§–£–ù–ö–¶–ò–ò –í–ï–†–°–ò–ò –ò –ü–û–ò–°–ö–ê ---

get_raw_bot_version() {
    if [[ -n "$BOT_CONTAINER_NAME" ]] && docker container inspect -f '{{.State.Running}}' "$BOT_CONTAINER_NAME" &>/dev/null; then
        local full_image=$(docker inspect -f '{{.Config.Image}}' "$BOT_CONTAINER_NAME")
        local ver="${full_image##*:}"
        echo "${ver:-Unknown}"
    else
        echo ""
    fi
}

get_bot_version_display() {
    local ver=$(get_raw_bot_version)
    if [[ -n "$ver" ]]; then echo "$ver"; else echo "–ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ / –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"; fi
}

detect_bot_installation() {
    print_message "INFO" "–ó–∞–ø—É—Å–∫ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞..."
    scan_system_for_bot 
    if [[ -n "$FOUND_PATH" ]]; then
        echo ""; print_message "SUCCESS" "–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∞!"
        echo -e "   –ü—É—Ç—å:      ${BOLD}$FOUND_PATH${RESET}"
        [[ -n "$FOUND_BOT" ]] && echo -e "   –ë–æ—Ç:       ${BOLD}$FOUND_BOT${RESET}"
        [[ -n "$FOUND_DB" ]]  && echo -e "   –ë–î:        ${BOLD}$FOUND_DB${RESET}"
        echo ""
        read -erp "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏? (Y/n): " confirm
        if [[ -z "$confirm" || "$confirm" =~ ^[Yy]$ ]]; then
            BOT_PATH="$FOUND_PATH"
            if [[ -n "$FOUND_BOT" ]]; then BOT_CONTAINER_NAME="$FOUND_BOT"; fi
            if [[ -n "$FOUND_DB" ]]; then DB_CONTAINER_NAME="$FOUND_DB"; fi
            save_config; print_message "SUCCESS" "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã."; return 0
        fi
    fi
    print_message "WARN" "–ê–≤—Ç–æ-–ø–æ–∏—Å–∫ –Ω–µ –¥–∞–ª —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞. –í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –≤—Ä—É—á–Ω—É—é –≤ –ù–∞—Å—Ç—Ä–æ–π–∫–∞—Ö."
    return 1
}

# --- –ü–†–û–í–ï–†–ö–ê –ù–ï–°–û–û–¢–í–ï–¢–°–¢–í–ò–ô ---

check_config_mismatch() {
    if [[ -n "$BOT_CONTAINER_NAME" && "$IGNORE_MISMATCH" != "true" ]]; then
        if ! docker inspect "$BOT_CONTAINER_NAME" &>/dev/null; then
            scan_system_for_bot
            if [[ -n "$FOUND_BOT" && "$FOUND_BOT" != "$BOT_CONTAINER_NAME" ]]; then
                echo ""; print_message "WARN" "–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä '$BOT_CONTAINER_NAME' –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–æ –Ω–∞–π–¥–µ–Ω '$FOUND_BOT'."
                echo -e " ${GREEN}–ü—Ä–µ–¥–ª–∞–≥–∞—é –æ–±–Ω–æ–≤–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.${RESET}"
                read -erp "–û–±–Ω–æ–≤–∏—Ç—å? (Y/n): " upd
                if [[ -z "$upd" || "$upd" =~ ^[Yy]$ ]]; then
                    BOT_CONTAINER_NAME="$FOUND_BOT"
                    [[ -n "$FOUND_DB" ]] && DB_CONTAINER_NAME="$FOUND_DB"
                    [[ -n "$FOUND_PATH" ]] && BOT_PATH="$FOUND_PATH"
                    save_config; print_message "SUCCESS" "–û–±–Ω–æ–≤–ª–µ–Ω–æ."; sleep 1
                else
                    IGNORE_MISMATCH="true"; save_config
                fi
            fi
        fi
    fi
}

ensure_bot_path() {
    if [[ -z "$BOT_CONTAINER_NAME" || -z "$DB_CONTAINER_NAME" ]]; then
        echo ""; print_message "WARN" "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ –ø—É—Å—Ç—ã."
        detect_bot_installation; load_or_create_config 
    fi

    local path_valid=false
    if [[ -n "$BOT_PATH" && -d "$BOT_PATH" && ( -f "$BOT_PATH/docker-compose.yml" || -f "$BOT_PATH/compose.yaml" ) ]]; then path_valid=true; fi
    local container_valid=false
    if [[ -n "$BOT_CONTAINER_NAME" ]] && docker inspect "$BOT_CONTAINER_NAME" &>/dev/null; then container_valid=true; fi
    local db_valid=false
    if [[ -n "$DB_CONTAINER_NAME" ]] && docker inspect "$DB_CONTAINER_NAME" &>/dev/null; then db_valid=true; fi

    if [[ "$path_valid" == "false" || "$container_valid" == "false" || "$db_valid" == "false" ]]; then
        if [[ "$path_valid" == "false" ]]; then
            detect_bot_installation; load_or_create_config
            if [[ -n "$BOT_PATH" ]]; then path_valid=true; fi
            if [[ -n "$BOT_CONTAINER_NAME" ]]; then container_valid=true; fi
            if [[ -n "$DB_CONTAINER_NAME" ]]; then db_valid=true; fi
        fi

        if [[ -z "$BOT_PATH" || ! -d "$BOT_PATH" ]]; then
            echo ""; print_message "ACTION" "–£–∫–∞–∂–∏—Ç–µ –ø—É—Ç—å –∫ –ø–∞–ø–∫–µ –±–æ—Ç–∞ –≤—Ä—É—á–Ω—É—é."
            read -erp "–ü—É—Ç—å (Enter –¥–ª—è '$DEFAULT_BOT_PATH'): " input_path
            BOT_PATH="${input_path:-$DEFAULT_BOT_PATH}"
            if [[ ! -d "$BOT_PATH" ]]; then print_message "ERROR" "–ü–∞–ø–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!"; return 1; fi
            save_config
        fi

        if [[ -z "$BOT_CONTAINER_NAME" ]] || ! docker inspect "$BOT_CONTAINER_NAME" &>/dev/null; then
            echo ""; print_message "WARN" "–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –±–æ—Ç–∞ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω."
            print_message "ACTION" "–í–≤–µ–¥–∏—Ç–µ –∏–º—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –±–æ—Ç–∞ (–∫–∞–∫ –≤ 'docker ps')."
            read -erp "–ò–º—è: " input_name
            if [[ -n "$input_name" ]]; then BOT_CONTAINER_NAME="$input_name"; else BOT_CONTAINER_NAME="shopbot"; fi
            save_config
        fi

        if [[ -z "$DB_CONTAINER_NAME" ]] || ! docker inspect "$DB_CONTAINER_NAME" &>/dev/null; then
            echo ""; print_message "WARN" "–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –ë–∞–∑—ã –î–∞–Ω–Ω—ã—Ö –Ω–µ –Ω–∞–π–¥–µ–Ω."
            print_message "ACTION" "–í–≤–µ–¥–∏—Ç–µ –∏–º—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –ë–î (–∏–ª–∏ Enter –¥–ª—è '$DEFAULT_DB_NAME')."
            read -erp "–ò–º—è –ë–î: " input_db
            if [[ -n "$input_db" ]]; then DB_CONTAINER_NAME="$input_db"; else DB_CONTAINER_NAME="$DEFAULT_DB_NAME"; fi
            save_config
        fi
    fi
    return 0
}

save_config() {
    mkdir -p "$INSTALL_DIR"
    cat > "$CONFIG_FILE" <<EOF
BOT_TOKEN="$BOT_TOKEN"
CHAT_ID="$CHAT_ID"
TG_MESSAGE_THREAD_ID="$TG_MESSAGE_THREAD_ID"
BOT_PATH="$BOT_PATH"
DB_USER="$DB_USER"
SCHEDULE_FULL="$SCHEDULE_FULL"
SCHEDULE_DB="$SCHEDULE_DB"
SCHEDULE_FILES="$SCHEDULE_FILES"
MAX_BACKUPS_COUNT="$MAX_BACKUPS_COUNT"
BOT_CONTAINER_NAME="$BOT_CONTAINER_NAME"
DB_CONTAINER_NAME="$DB_CONTAINER_NAME"
IGNORE_MISMATCH="$IGNORE_MISMATCH"
EXCLUDE_DIRS="$EXCLUDE_DIRS"
MAX_FILE_SIZE_MB="$MAX_FILE_SIZE_MB"
REMOTE_STORAGE_TYPE="$REMOTE_STORAGE_TYPE"
REMOTE_STORAGE_URL="$REMOTE_STORAGE_URL"
REMOTE_STORAGE_USER="$REMOTE_STORAGE_USER"
REMOTE_STORAGE_PASS="$REMOTE_STORAGE_PASS"
BACKUP_PASSWORD="$BACKUP_PASSWORD"
SEND_TO_TELEGRAM="$SEND_TO_TELEGRAM"
SEND_TO_REMOTE="$SEND_TO_REMOTE"
DELETE_MODE="$DELETE_MODE"
RETENTION_DAYS="$RETENTION_DAYS"
EOF
    chmod 600 "$CONFIG_FILE"
}

load_or_create_config() {
    if [[ -f "$CONFIG_FILE" ]]; then source "$CONFIG_FILE"; fi
    if [[ -z "$MAX_BACKUPS_COUNT" ]]; then MAX_BACKUPS_COUNT=100; fi
    if [[ -z "$IGNORE_MISMATCH" ]]; then IGNORE_MISMATCH="false"; fi
    if [[ -z "$MAX_FILE_SIZE_MB" ]]; then MAX_FILE_SIZE_MB="1"; fi
    if [[ -z "$REMOTE_STORAGE_TYPE" ]]; then REMOTE_STORAGE_TYPE="off"; fi
    if [[ -z "$SEND_TO_TELEGRAM" ]]; then SEND_TO_TELEGRAM="true"; fi
    if [[ -z "$SEND_TO_REMOTE" ]]; then SEND_TO_REMOTE="true"; fi
    if [[ -z "$DELETE_MODE" ]]; then DELETE_MODE="time"; fi
    if [[ -z "$RETENTION_DAYS" ]]; then RETENTION_DAYS="7"; fi
    mkdir -p "$BACKUP_DIR"

    local updated=false
    if [[ -z "$BOT_TOKEN" || -z "$CHAT_ID" ]]; then
        echo ""; print_message "WARN" "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ Telegram –Ω–µ –Ω–∞–π–¥–µ–Ω—ã."
        [[ -z "$BOT_TOKEN" ]] && read -erp " –í–≤–µ–¥–∏—Ç–µ Bot Token: " BOT_TOKEN
        [[ -z "$CHAT_ID" ]] && read -erp " –í–≤–µ–¥–∏—Ç–µ Chat ID: " CHAT_ID
        [[ -z "$TG_MESSAGE_THREAD_ID" ]] && read -erp " –í–≤–µ–¥–∏—Ç–µ ID —Ç–æ–ø–∏–∫–∞ (–∏–ª–∏ Enter): " TG_MESSAGE_THREAD_ID
        updated=true
    fi
    
    if [[ -z "$BOT_PATH" || -z "$BOT_CONTAINER_NAME" || -z "$DB_CONTAINER_NAME" ]]; then 
        detect_bot_installation
    fi
    
    if $updated; then save_config; fi
}

send_telegram_document() {
    if [[ "$SEND_TO_TELEGRAM" != "true" ]]; then
        print_message "INFO" "–û—Ç–ø—Ä–∞–≤–∫–∞ –≤ Telegram –æ—Ç–∫–ª—é—á–µ–Ω–∞ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö."
        return
    fi

    local file_path="$1"; local caption="$2"
    [[ -z "$BOT_TOKEN" || -z "$CHAT_ID" ]] && return 1
    
    print_message "INFO" "–û—Ç–ø—Ä–∞–≤–∫–∞ –≤ Telegram..."
    
    local form_params=(-F chat_id="$CHAT_ID" -F document=@"$file_path" -F parse_mode="MarkdownV2" -F caption="$(escape_markdown_v2 "$caption")")
    [[ -n "$TG_MESSAGE_THREAD_ID" ]] && form_params+=(-F message_thread_id="$TG_MESSAGE_THREAD_ID")
    
    local http_code=$(curl -s -o /dev/null -w "%{http_code}" -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendDocument" "${form_params[@]}")
    
    if [[ "$http_code" == "200" ]]; then
        print_message "SUCCESS" "–£—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ Telegram."
    else
        local file_size=$(stat -c%s "$file_path" 2>/dev/null || echo 0)
        
        if [[ $file_size -ge 52428800 ]]; then
            print_message "ERROR" "–§–∞–π–ª >50MB. Telegram API –æ—Ç–∫–ª–æ–Ω–∏–ª –æ—Ç–ø—Ä–∞–≤–∫—É."
            local error_msg="‚ö†Ô∏è *–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –±—ç–∫–∞–ø–∞*

–§–∞–π–ª –∑–∞–Ω–∏–º–∞–µ—Ç –±–æ–ª—å—à–µ 50 –ú–ë\. Telegram Bot API –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç –∑–∞–≥—Ä—É–∂–∞—Ç—å —Ç–∞–∫–∏–µ —Ñ–∞–π–ª—ã –Ω–∞–ø—Ä—è–º—É—é\.

üìÇ *–ë—ç–∫–∞–ø —Å–æ—Ö—Ä–∞–Ω–µ–Ω –ª–æ–∫–∞–ª—å–Ω–æ:*
\`$(basename "$file_path")\`"
            
            local thread_param=""
            [[ -n "$TG_MESSAGE_THREAD_ID" ]] && thread_param="-d message_thread_id=$TG_MESSAGE_THREAD_ID"

            curl -s -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" \
                -d chat_id="$CHAT_ID" \
                -d text="$error_msg" \
                -d parse_mode="MarkdownV2" \
                $thread_param >/dev/null
        else
            print_message "ERROR" "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ Telegram (HTTP –∫–æ–¥: $http_code)."
        fi
    fi
}

send_telegram_text() {
    # send simple text message to configured chat
    local text="$1"
    [[ -z "$BOT_TOKEN" || -z "$CHAT_ID" ]] && return 1
    local thread_param=""
    [[ -n "$TG_MESSAGE_THREAD_ID" ]] && thread_param="-d message_thread_id=$TG_MESSAGE_THREAD_ID"
    curl -s -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" \
        -d chat_id="$CHAT_ID" \
        -d text="$text" \
        -d parse_mode="MarkdownV2" $thread_param >/dev/null 2>&1
}

test_telegram_connection() {
    print_message "INFO" "–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤—è–∑–∏ —Å Telegram API..."
    local res=$(curl -s "https://api.telegram.org/bot$BOT_TOKEN/getMe")
    if [[ "$res" == *'"ok":true'* ]]; then
        local bot_user=$(echo "$res" | grep -o '"username":"[^"]*"' | cut -d'"' -f4)
        print_message "SUCCESS" "–£—Å–ø–µ—Ö! –ë–æ—Ç: @$bot_user"
    else
        print_message "ERROR" "–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ç–æ–∫–µ–Ω."
    fi
    read -erp "Enter..." dummy
}

validate_remote_connection() {
    local type="$1"; local url="$2"; local user="$3"; local pass="$4"
    print_message "INFO" "–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è ($type)..."
    local base_url="${url%/}"; local curl_cmd=(curl -s -m 10)
    [[ -n "$user" ]] && curl_cmd+=(--user "$user:$pass")

    if [[ "$type" == "ftp" ]]; then
        if "${curl_cmd[@]}" --list-only "$base_url/" >/dev/null 2>&1; then return 0; else return 1; fi
    elif [[ "$type" == "webdav" ]]; then
        local http_code=$("${curl_cmd[@]}" -o /dev/null -w "%{http_code}" -X PROPFIND -H "Depth: 0" "$base_url/" 2>/dev/null)
        if [[ "$http_code" =~ ^(200|207|301|405)$ ]]; then return 0; else return 1; fi
    elif [[ "$type" == "rclone" ]]; then
        # For rclone, url is the remote name (e.g. "gdrive:")
        if rclone listremotes | grep -q "^${url%:}\+:$"; then return 0; fi
        if rclone lsd "$url" >/dev/null 2>&1; then return 0; else return 1; fi
    fi
    return 1
}

upload_to_remote() {
    if [[ "$SEND_TO_REMOTE" != "true" ]]; then return; fi
    local file_path="$1"; local filename=$(basename "$file_path")
    REMOTE_UPLOAD_STATUS_TEXT="" 

    if [[ "$REMOTE_STORAGE_TYPE" == "off" || -z "$REMOTE_STORAGE_URL" ]]; then return; fi

    print_message "INFO" "–ó–∞–≥—Ä—É–∑–∫–∞ –Ω–∞ —É–¥–∞–ª–µ–Ω–Ω—ã–π —Å–µ—Ä–≤–µ—Ä ($REMOTE_STORAGE_TYPE)..." >&2

    if [[ "$REMOTE_STORAGE_TYPE" == "rclone" ]]; then
        # Rclone upload
        if ! command -v rclone >/dev/null 2>&1; then
             print_message "ERROR" "Rclone –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!"
             return
        fi
        local dest="${REMOTE_STORAGE_URL%/}"
        if rclone copy "$file_path" "$dest" --progress; then
             print_message "SUCCESS" "–§–∞–π–ª —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω (rclone)."
             REMOTE_UPLOAD_STATUS_TEXT=$'\n‚òÅÔ∏è Rclone: OK'
             log_message "SUCCESS" "Uploaded $file_path to rclone:$dest"
        else
             print_message "ERROR" "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ rclone."
             log_message "ERROR" "Failed upload $file_path to rclone:$dest"
        fi
        return
    fi

    local upload_url="${REMOTE_STORAGE_URL%/}/$filename"
    local curl_cmd=(curl -# -o /dev/null -w "%{http_code}" -m 300 -T "$file_path")
    
    [[ -n "$REMOTE_STORAGE_USER" ]] && curl_cmd+=(--user "$REMOTE_STORAGE_USER:$REMOTE_STORAGE_PASS")
    [[ "$REMOTE_STORAGE_TYPE" == "ftp" ]] && curl_cmd+=("$upload_url")
    [[ "$REMOTE_STORAGE_TYPE" == "webdav" ]] && curl_cmd+=("$upload_url")

    local http_code=""
    if [[ "$IS_INTERACTIVE" == "true" ]]; then
        http_code=$("${curl_cmd[@]}")
    else
        curl_cmd[1]="-s"
        http_code=$("${curl_cmd[@]}")
    fi

    if [[ "$http_code" =~ ^(200|201|204|226)$ ]]; then
        print_message "SUCCESS" "–§–∞–π–ª —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ." >&2
        if [[ "$REMOTE_STORAGE_TYPE" == "ftp" ]]; then REMOTE_UPLOAD_STATUS_TEXT=$'\n‚òÅÔ∏è FTP: OK'; else REMOTE_UPLOAD_STATUS_TEXT=$'\n‚òÅÔ∏è WebDAV: OK'; fi
        log_message "SUCCESS" "Uploaded $file_path to $REMOTE_STORAGE_TYPE ($upload_url) HTTP=$http_code"
    else
        print_message "ERROR" "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ (–ö–æ–¥: $http_code)." >&2
        if [[ "$REMOTE_STORAGE_TYPE" == "ftp" ]]; then REMOTE_UPLOAD_STATUS_TEXT=$'\n‚òÅÔ∏è FTP: –û—à–∏–±–∫–∞'; else REMOTE_UPLOAD_STATUS_TEXT=$'\n‚òÅÔ∏è WebDAV: –û—à–∏–±–∫–∞'; fi
        log_message "ERROR" "Failed upload $file_path to $REMOTE_STORAGE_TYPE ($upload_url) HTTP=$http_code"
    fi
}

configure_remote_storage() {
    clear; echo -e "${CYAN}–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞${RESET}"
    echo "1. –¢–∏–ø: FTP"
    echo "2. –¢–∏–ø: WebDAV"
    echo "3. –¢–∏–ø: Rclone (—Ç—Ä–µ–±—É–µ—Ç—Å—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–π rclone)"
    echo "4. –û—Ç–∫–ª—é—á–∏—Ç—å"
    echo ""; read -erp "–í—ã–±–æ—Ä: " r_type
    
    local new_type="off"
    case $r_type in
        1) new_type="ftp" ;; 2) new_type="webdav" ;; 3) new_type="rclone" ;;
        4) REMOTE_STORAGE_TYPE="off"; save_config; print_message "SUCCESS" "–û—Ç–∫–ª—é—á–µ–Ω–æ."; return ;;
        *) return ;;
    esac

    if [[ "$new_type" == "rclone" ]]; then
        echo ""; echo "–í–≤–µ–¥–∏—Ç–µ –∏–º—è remote –∏ –ø—É—Ç—å (–∫–∞–∫ –≤ rclone), –Ω–∞–ø—Ä–∏–º–µ—Ä: gdrive:backups"
        read -erp "Rclone path: " input_url
        input_user=""; input_pass=""
    else
        echo ""; echo "–ü—Ä–∏–º–µ—Ä URL: ftp://backup.server.com/folder  |  https://webdav.yandex.ru"; echo ""
        read -erp "URL —Å–µ—Ä–≤–µ—Ä–∞: " input_url
        read -erp "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: " input_user
        read -s -erp "–ü–∞—Ä–æ–ª—å: " input_pass; echo ""
    fi

    if validate_remote_connection "$new_type" "$input_url" "$input_user" "$input_pass"; then
        print_message "SUCCESS" "–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ!"
        REMOTE_STORAGE_TYPE="$new_type"; REMOTE_STORAGE_URL="$input_url"; REMOTE_STORAGE_USER="$input_user"; REMOTE_STORAGE_PASS="$input_pass"
        save_config; print_message "SUCCESS" "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã."
    else
        print_message "ERROR" "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É!"
        read -erp "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ –æ—à–∏–±–∫—É? (y/N): " force_save
        if [[ "$force_save" =~ ^[Yy]$ ]]; then
            REMOTE_STORAGE_TYPE="$new_type"; REMOTE_STORAGE_URL="$input_url"; REMOTE_STORAGE_USER="$input_user"; REMOTE_STORAGE_PASS="$input_pass"
            save_config; print_message "WARN" "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã (–Ω–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ)."
        else
            print_message "INFO" "–û—Ç–º–µ–Ω–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è."
        fi
    fi
    sleep 1
}

# --- –†–û–¢–ê–¶–ò–Ø (–£–î–ê–õ–ï–ù–ò–ï –õ–ò–®–ù–ò–•) ---

rotate_backups_by_count() {
    local PREFIX="$1"
    local LABEL="$2"
    local PERFORM_DELETE="$3" 
    
    # –°–¢–†–û–ì–ò–ô –ü–û–ò–°–ö (–¢–æ–ª—å–∫–æ –∞—Ä—Ö–∏–≤—ã), —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ (—Å—Ç–∞—Ä—ã–µ –≤ –Ω–∞—á–∞–ª–µ)
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º ls -1tr –¥–ª—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –∏ while read –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∏–º–µ–Ω —Å –ø—Ä–æ–±–µ–ª–∞–º–∏
    local files=()
    while IFS= read -r f; do
        files+=("$f")
    done < <(ls -1tr "$BACKUP_DIR"/${PREFIX}_*.tar.gz "$BACKUP_DIR"/${PREFIX}_*.tar.gz.enc 2>/dev/null)
    
    local count=${#files[@]}
    local diff=$((count - MAX_BACKUPS_COUNT))
    
    if [[ $diff -gt 0 ]]; then
        if [[ "$PERFORM_DELETE" == "true" ]]; then
            if [[ "$DRY_RUN" == "true" ]]; then
                echo -e "${YELLOW}[DRY-RUN] –ö–∞—Ç–µ–≥–æ—Ä–∏—è '$LABEL': –±—ã–ª–æ –±—ã —É–¥–∞–ª–µ–Ω–æ $diff —Å—Ç–∞—Ä—ã—Ö —Ñ–∞–π–ª–æ–≤ (–ª–∏–º–∏—Ç $MAX_BACKUPS_COUNT).${RESET}"
                log_message "INFO" "[DRY_RUN] Would delete $diff files (count-based rotation, prefix=$PREFIX, limit=$MAX_BACKUPS_COUNT)"
                echo "$diff"
                return 0
            fi
            echo -e "${YELLOW}–û—á–∏—Å—Ç–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ '$LABEL' (—É–¥–∞–ª–µ–Ω–∏–µ $diff —Å—Ç–∞—Ä—ã—Ö —Ñ–∞–π–ª–æ–≤):${RESET}"
            for (( i=0; i<diff; i++ )); do
                local file_to_del="${files[$i]}"
                if [[ -f "$file_to_del" ]]; then
                    rm -f "$file_to_del"
                    rm -f "$file_to_del.version"
                    echo "  üóë –£–¥–∞–ª–µ–Ω: $(basename "$file_to_del")"
                    log_message "INFO" "Deleted $file_to_del (count-based rotation, prefix=$PREFIX)"
                fi
            done
            echo "$diff"
            return 0
        else
            echo -e " $LABEL: –ù–∞–π–¥–µ–Ω–æ $count (–õ–∏–º–∏—Ç $MAX_BACKUPS_COUNT) -> ${RED}–ö–∞–Ω–¥–∏–¥–∞—Ç—ã –Ω–∞ —É–¥–∞–ª–µ–Ω–∏–µ: $diff —à—Ç.${RESET}"
            echo "$diff"
            return 0
        fi
        return 0
    else
        if [[ "$PERFORM_DELETE" != "true" ]]; then
            echo -e " $LABEL: –ù–∞–π–¥–µ–Ω–æ $count (–õ–∏–º–∏—Ç $MAX_BACKUPS_COUNT) -> ${GREEN}OK${RESET}"
        fi
        echo "0"
        return 0
    fi
}

rotate_backups_by_age() {
    local PREFIX="$1"
    local LABEL="$2"
    local DAYS="$3"
    local PERFORM_DELETE="$4"

    # –ò—â–µ–º —Ç–æ–ª—å–∫–æ –∞—Ä—Ö–∏–≤—ã (–≤–∫–ª—é—á–∞—è .enc)
    local pattern1="$BACKUP_DIR/${PREFIX}_*.tar.gz"
    local pattern2="$BACKUP_DIR/${PREFIX}_*.tar.gz.enc"

    # –ù–∞–π–¥—ë–º —Ñ–∞–π–ª—ã —Å—Ç–∞—Ä—à–µ DAYS –¥–Ω–µ–π
    local files=()
    # find -mtime +N –æ–∑–Ω–∞—á–∞–µ—Ç "—Å—Ç—Ä–æ–≥–æ –±–æ–ª—å—à–µ N –¥–Ω–µ–π". –ß—Ç–æ–±—ã RETENTION_DAYS=N –æ–∑–Ω–∞—á–∞–ª
    # "—É–¥–∞–ª—è—Ç—å —Ñ–∞–π–ª—ã —Å—Ç–∞—Ä—à–µ N –¥–Ω–µ–π", –∏—Å–ø–æ–ª—å–∑—É–µ–º -mtime +$((N-1)). –î–ª—è N==0 ‚Äî –±—É–¥–µ–º
    # —É–¥–∞–ª—è—Ç—å –≤—Å–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–µ —Ñ–∞–π–ª—ã.
    # –°–æ–±–∏—Ä–∞–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç—ã find –±–µ–∑ eval
    local find_args=("$BACKUP_DIR" -maxdepth 1 \( -name "${PREFIX}_*.tar.gz" -o -name "${PREFIX}_*.tar.gz.enc" \) -type f)
    if [[ "$DAYS" -le 0 ]]; then
        # –ï—Å–ª–∏ 0 –∏–ª–∏ –º–µ–Ω—å—à–µ - –Ω–µ —É–¥–∞–ª—è–µ–º –Ω–∏—á–µ–≥–æ (–∑–∞—â–∏—Ç–∞ –æ—Ç –ø–æ–ª–Ω–æ–π –æ—á–∏—Å—Ç–∫–∏)
        return 0
    else
        local nd=$((DAYS - 1))
        find_args+=( -mtime +"$nd" )
    fi
    find_args+=( -print0 )
    while IFS= read -r -d $'\0' f; do files+=("$f"); done < <(find "${find_args[@]}" 2>/dev/null)

    local count=${#files[@]}

    if [[ $count -gt 0 ]]; then
        if [[ "$PERFORM_DELETE" == "true" ]]; then
            if [[ "$DRY_RUN" == "true" ]]; then
                echo -e "${YELLOW}[DRY-RUN] –ö–∞—Ç–µ–≥–æ—Ä–∏—è '$LABEL': –±—ã–ª–æ –±—ã —É–¥–∞–ª–µ–Ω–æ $count —Ñ–∞–π–ª–æ–≤ —Å—Ç–∞—Ä—à–µ $DAYS –¥–Ω–µ–π.${RESET}"
                log_message "INFO" "[DRY_RUN] Would delete $count files (age-based rotation, prefix=$PREFIX, days=$DAYS)"
                echo "$count"
                return 0
            fi
            echo -e "${YELLOW}–û—á–∏—Å—Ç–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ '$LABEL' (—É–¥–∞–ª–µ–Ω–∏–µ $count —Ñ–∞–π–ª–æ–≤ —Å—Ç–∞—Ä—à–µ $DAYS –¥–Ω–µ–π):${RESET}"
            for f in "${files[@]}"; do
                if [[ -f "$f" ]]; then
                    rm -f "$f"
                    rm -f "$f.version"
                    echo "  üóë –£–¥–∞–ª–µ–Ω: $(basename "$f")"
                    log_message "INFO" "Deleted $f (age-based rotation, prefix=$PREFIX, days=$DAYS)"
                fi
            done
            echo "$count"
            return 0
        else
            echo -e " $LABEL: –ù–∞–π–¥–µ–Ω–æ $count —Ñ–∞–π–ª–æ–≤ —Å—Ç–∞—Ä—à–µ $DAYS –¥–Ω–µ–π -> ${RED}–ö–∞–Ω–¥–∏–¥–∞—Ç—ã –Ω–∞ —É–¥–∞–ª–µ–Ω–∏–µ: $count —à—Ç.${RESET}"
            echo "$count"
            return 0
        fi
        return 0
    else
        if [[ "$PERFORM_DELETE" != "true" ]]; then
            echo -e " $LABEL: –ù–µ—Ç —Ñ–∞–π–ª–æ–≤ —Å—Ç–∞—Ä—à–µ $DAYS –¥–Ω–µ–π -> ${GREEN}OK${RESET}"
        fi
        echo "0"
        return 0
    fi
}

uninstall_script() {
    if [[ "$EUID" -ne 0 ]]; then
        print_message "ERROR" "Uninstall requires root (sudo)."
        return 1
    fi
    echo ""
    print_message "WARN" "–£–¥–∞–ª–µ–Ω–∏–µ —Å–∫—Ä–∏–ø—Ç–∞ –∏ –¥–∞–Ω–Ω—ã—Ö —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –±—É–¥–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–æ.";
    read -erp "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å? (y/N): " ans
    if [[ ! "$ans" =~ ^[Yy]$ ]]; then print_message "INFO" "–û—Ç–º–µ–Ω–µ–Ω–æ."; return 0; fi

    # remove symlink
    if [[ -L "$SYMLINK_PATH" ]]; then
        rm -f "$SYMLINK_PATH" && log_message "INFO" "Removed symlink $SYMLINK_PATH"
    fi
    # remove installed script
    if [[ -f "$INSTALL_DIR/$SCRIPT_NAME" ]]; then
        rm -f "$INSTALL_DIR/$SCRIPT_NAME" && log_message "INFO" "Removed $INSTALL_DIR/$SCRIPT_NAME"
    fi
    # remove config and backups (ask)
    if [[ -d "$INSTALL_DIR" ]]; then
        read -erp "–£–¥–∞–ª–∏—Ç—å –ø–∞–ø–∫—É $INSTALL_DIR –∏ –≤—Å–µ –±—ç–∫–∞–ø—ã? (y/N): " r2
        if [[ "$r2" =~ ^[Yy]$ ]]; then
            rm -rf "$INSTALL_DIR" && log_message "INFO" "Removed $INSTALL_DIR"
        else
            log_message "INFO" "Preserved $INSTALL_DIR"
        fi
    fi
    # try to remove cron entries
    crontab -l 2>/dev/null | grep -v "# LAZARUS-JOB-" | crontab - 2>/dev/null || true
    log_message "INFO" "Attempted to remove cron entries for lazarus"
    print_message "SUCCESS" "Uninstall finished."
}

# --- –ë–≠–ö–ê–ü ---

create_backup() {
    local TYPE="$1"
    
    acquire_lock

    if [[ -z "$BACKUP_PASSWORD" && "$IS_INTERACTIVE" == "true" ]]; then
        clear
        echo -e "${RED}${BOLD}‚ö†Ô∏è –í–ù–ò–ú–ê–ù–ò–ï: –ü–∞—Ä–æ–ª—å —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!${RESET}"
        echo "–§–∞–π–ª –±—ç–∫–∞–ø–∞ –Ω–µ –±—É–¥–µ—Ç –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω. –î–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã —Ç—Ä–µ—Ç—å–∏–º –ª–∏—Ü–∞–º."
        echo ""
        echo " 1. –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –±–µ–∑ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è"
        echo " 2. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–∞—Ä–æ–ª—å —Å–µ–π—á–∞—Å"
        echo " 0. –û—Ç–º–µ–Ω–∞"
        echo ""
        read -erp "–í–∞—à –≤—ã–±–æ—Ä: " enc_choice
        case $enc_choice in
            1) ;; 
            2) read -s -erp "–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: " np
               echo ""; if [[ -n "$np" ]]; then BACKUP_PASSWORD="$np"; save_config; print_message "SUCCESS" "–ü–∞—Ä–æ–ª—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω."; else print_message "ERROR" "–ü—É—Å—Ç–æ–π –ø–∞—Ä–æ–ª—å. –û—Ç–º–µ–Ω–∞."; return; fi ;;
            *) print_message "INFO" "–ë—ç–∫–∞–ø –æ—Ç–º–µ–Ω–µ–Ω."; return ;;
        esac
    fi

    local TIMESTAMP=$(date +%Y-%m-%d"_"%H_%M_%S)
    
    # Create temp dir for atomic operations
    local TMP_WORK_DIR=$(mktemp -d)
    TEMP_DIRS+=("$TMP_WORK_DIR")
    
    local FILE_DB="db_${TIMESTAMP}.sql.gz"
    local FILE_DIR="dir_${TIMESTAMP}.tar.gz"
    local FILE_VERSION="bot_version.txt"
    local FILE_FINAL=""
    local HAS_ERROR=0
    local SKIP_INFO=""
    local SKIP_FILE="$TMP_WORK_DIR/skipped_files.txt"

    if [[ "$TYPE" != "db_only" ]]; then if ! ensure_bot_path; then return; fi; fi
    if [[ "$TYPE" == "db_only" || "$TYPE" == "full" ]]; then
        if [[ -z "$DB_CONTAINER_NAME" ]]; then ensure_bot_path; fi
    fi

    local CURRENT_VER=$(get_raw_bot_version)
    echo "${CURRENT_VER:-Unknown}" > "$TMP_WORK_DIR/$FILE_VERSION"

    if [[ "$TYPE" == "full" || "$TYPE" == "db_only" ]]; then
        print_message "INFO" "–î–∞–º–ø –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö ($DB_CONTAINER_NAME)..."
        if ! docker container inspect -f '{{.State.Running}}' "$DB_CONTAINER_NAME" &>/dev/null; then
             print_message "ERROR" "–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä DB ($DB_CONTAINER_NAME) –Ω–µ –∑–∞–ø—É—â–µ–Ω –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω!"
             HAS_ERROR=1
        else
            # Use pipefail to catch pg_dump errors
            if ! (set -o pipefail; docker exec "$DB_CONTAINER_NAME" pg_dumpall -c -U "$DB_USER" 2>/dev/null | gzip -9 > "$TMP_WORK_DIR/$FILE_DB"); then
                print_message "ERROR" "–û—à–∏–±–∫–∞ –¥–∞–º–ø–∞ –ë–î."
                HAS_ERROR=1
            fi
        fi
    fi

    if [[ $HAS_ERROR -eq 1 ]]; then return; fi

    IFS=' ' read -r -a EXCLUDE_ARRAY <<< "$EXCLUDE_DIRS"
    EXCLUDE_FLAGS=()
    for ex in "${EXCLUDE_ARRAY[@]}"; do if [[ -n "$ex" ]]; then EXCLUDE_FLAGS+=(--exclude="$ex"); fi; done
    EXCLUDE_FLAGS+=(--exclude="*.log" --exclude=".git" --exclude="private-remnawave-*.tar")

    if [[ "$TYPE" != "db_only" ]]; then
        : > "$SKIP_FILE"
        local FIND_CMD="find ."
        for ex in "${EXCLUDE_ARRAY[@]}"; do if [[ -n "$ex" ]]; then FIND_CMD+=" -path './$ex' -prune -o"; fi; done
        FIND_CMD+=" -type f -size +${MAX_FILE_SIZE_MB}M -print"
        cd "$BOT_PATH"; eval "$FIND_CMD" > "$SKIP_FILE"
        local SKIP_COUNT=$(wc -l < "$SKIP_FILE")
        if [[ "$SKIP_COUNT" -gt 0 ]]; then
            local SKIP_SIZE=$(du -ch --files0-from=<(tr '\n' '\0' < "$SKIP_FILE") | tail -1 | cut -f1)
            print_message "WARN" "–ü—Ä–æ–ø—É—â–µ–Ω–æ –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤ (>${MAX_FILE_SIZE_MB}MB): $SKIP_COUNT (–æ–±—â–∏–π –≤–µ—Å: $SKIP_SIZE)"
            EXCLUDE_FLAGS+=(--exclude-from="$SKIP_FILE")
            SKIP_INFO=$'\n‚ö†Ô∏è Skip: '"$SKIP_COUNT"$' (>'"$MAX_FILE_SIZE_MB"$'MB)'
        fi
    fi

    if [[ "$TYPE" == "db_only" ]]; then
        FILE_FINAL="lazarus_db_${TIMESTAMP}.tar.gz"
        tar -czf "$TMP_WORK_DIR/$FILE_FINAL" -C "$TMP_WORK_DIR" "$FILE_VERSION" "$FILE_DB"
    elif [[ "$TYPE" == "files_only" ]]; then
        FILE_FINAL="lazarus_files_${TIMESTAMP}.tar.gz"
        print_message "INFO" "–ê—Ä—Ö–∏–≤–∞—Ü–∏—è —Ñ–∞–π–ª–æ–≤ (—ç—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –≤—Ä–µ–º—è)..."
        tar -czf "$TMP_WORK_DIR/$FILE_FINAL" -C "$TMP_WORK_DIR" "$FILE_VERSION" "${EXCLUDE_FLAGS[@]}" -C "$(dirname "$BOT_PATH")" "$(basename "$BOT_PATH")"
    else 
        FILE_FINAL="lazarus_full_${TIMESTAMP}.tar.gz"
        print_message "INFO" "–ê—Ä—Ö–∏–≤–∞—Ü–∏—è —Ñ–∞–π–ª–æ–≤ (—ç—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –≤—Ä–µ–º—è)..."
        tar -czf "$TMP_WORK_DIR/$FILE_DIR" "${EXCLUDE_FLAGS[@]}" -C "$(dirname "$BOT_PATH")" "$(basename "$BOT_PATH")"
        tar -czf "$TMP_WORK_DIR/$FILE_FINAL" -C "$TMP_WORK_DIR" "$FILE_VERSION" "$FILE_DB" "$FILE_DIR"
    fi

    local ENC_STATUS="üîì Unencrypted"
    if [[ -z "$BACKUP_PASSWORD" && "$IS_INTERACTIVE" == "false" ]]; then ENC_STATUS="‚ö†Ô∏è NO PASSWORD"; fi

    if [[ -n "$BACKUP_PASSWORD" ]]; then
        print_message "INFO" "–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∞—Ä—Ö–∏–≤–∞ (—ç—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –≤—Ä–µ–º—è)..."
        # Pass password via env var to avoid process listing leak
        export LAZARUS_ENC_PASS="$BACKUP_PASSWORD"
        openssl enc -aes-256-cbc -salt -pbkdf2 -in "$TMP_WORK_DIR/$FILE_FINAL" -out "$TMP_WORK_DIR/${FILE_FINAL}.enc" -pass env:LAZARUS_ENC_PASS
        local enc_res=$?
        unset LAZARUS_ENC_PASS
        
        if [[ $enc_res -eq 0 ]]; then
            rm "$TMP_WORK_DIR/$FILE_FINAL"
            FILE_FINAL="${FILE_FINAL}.enc"
            ENC_STATUS="üîí Encrypted"
            print_message "SUCCESS" "–ê—Ä—Ö–∏–≤ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω."
        else
            print_message "ERROR" "–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è! –û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–µ–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞."
        fi
    fi

    # Move final file to BACKUP_DIR
    mv "$TMP_WORK_DIR/$FILE_FINAL" "$BACKUP_DIR/$FILE_FINAL"
    local FINAL_VERSION_FILE="$BACKUP_DIR/$FILE_FINAL.version"
    cp "$TMP_WORK_DIR/$FILE_VERSION" "$FINAL_VERSION_FILE"
    
    # --- VERIFY ARCHIVE ---
    print_message "INFO" "–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ –∞—Ä—Ö–∏–≤–∞..."
    local VERIFY_OK="false"
    if [[ "$FILE_FINAL" == *".enc" ]]; then
        # For encrypted files, we can't easily verify without decrypting. 
        # We assume openssl exit code 0 was enough, or we could decrypt to /dev/null
        export LAZARUS_VERIFY_PASS="$BACKUP_PASSWORD"
        if openssl enc -d -aes-256-cbc -pbkdf2 -in "$BACKUP_DIR/$FILE_FINAL" -pass env:LAZARUS_VERIFY_PASS | gzip -t 2>/dev/null; then
             VERIFY_OK="true"
        fi
        unset LAZARUS_VERIFY_PASS
    else
        if gzip -t "$BACKUP_DIR/$FILE_FINAL" 2>/dev/null; then
             VERIFY_OK="true"
        fi
    fi

    if [[ "$VERIFY_OK" == "true" ]]; then
        print_message "SUCCESS" "–ê—Ä—Ö–∏–≤ –≤–∞–ª–∏–¥–µ–Ω."
    else
        print_message "ERROR" "–ê—Ä—Ö–∏–≤ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω! (Verification failed)"
        # We do not delete it, just warn
    fi

    local SIZE=$(du -h "$BACKUP_DIR/$FILE_FINAL" | awk '{print $1}')
    print_message "SUCCESS" "–ë—ç–∫–∞–ø —Å–æ–∑–¥–∞–Ω: $FILE_FINAL ($SIZE)"
    log_message "SUCCESS" "Backup created: $FILE_FINAL (type=$TYPE, size=$SIZE, enc_status=$ENC_STATUS, verify=$VERIFY_OK)"

    upload_to_remote "$BACKUP_DIR/$FILE_FINAL"
    
    local DISPLAY_DATE=$(date "+%d.%m.%Y %H:%M:%S")
    local HASHTAG=""; local TYPE_NAME=""; local ROTATION_KEY=""
    
    case "$TYPE" in
        "full") HASHTAG="üíæ #full_backup"; TYPE_NAME="üì¶ –ü–æ–ª–Ω—ã–π –±—ç–∫–∞–ø"; ROTATION_KEY="–ü–æ–ª–Ω—ã–µ –±—ç–∫–∞–ø—ã" ;;
        "db_only") HASHTAG="üíæ #db_only"; TYPE_NAME="üóÑ –î–∞–º–ø –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"; ROTATION_KEY="–ë–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö" ;;
        "files_only") HASHTAG="üíæ #files_only"; TYPE_NAME="üìÇ –§–∞–π–ª—ã –±–æ—Ç–∞"; ROTATION_KEY="–ê—Ä—Ö–∏–≤—ã —Ñ–∞–π–ª–æ–≤" ;;
    esac

    local VER_MSG=""; [[ -n "$CURRENT_VER" ]] && VER_MSG=" | üè∑ v${CURRENT_VER}"
    local CAPTION="${HASHTAG}
üìÖ ${DISPLAY_DATE}
${TYPE_NAME}
üìè ${SIZE}${VER_MSG}
${ENC_STATUS}${REMOTE_UPLOAD_STATUS_TEXT}${SKIP_INFO}"
    
    send_telegram_document "$BACKUP_DIR/$FILE_FINAL" "$CAPTION"

    rotate_backups_by_count "lazarus_$TYPE" "$ROTATION_KEY" "true"
}

# --- –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ò–ï ---

select_backup_file() {
    local FILTER_PREFIX="$1"; local TITLE="$2"
    local show_limit=5; local show_filenames=false

    while true; do
        local files_raw=("$BACKUP_DIR/${FILTER_PREFIX}_"*.tar.gz*)
        local valid_files=()
        for f in "${files_raw[@]}"; do
            if [[ ! -e "$f" ]]; then continue; fi 
            if [[ "$f" == *".version" ]]; then continue; fi
            if [[ ! "$f" =~ \.tar\.gz(\.enc)?$ ]]; then continue; fi
            valid_files+=("$f")
        done
        
        local total_count=${#valid_files[@]}
        
        if [[ "$total_count" -eq 0 ]]; then
            print_message "WARN" "–§–∞–π–ª–æ–≤ —Ç–∏–ø–∞ '${TITLE}' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ."; read -erp "Enter..." dummy; return 1
        fi
        
        IFS=$'\n' sorted_backups=($(sort -r <<<"${valid_files[*]}"))
        unset IFS
        
        local CURRENT_VER=$(get_raw_bot_version)

        clear; echo -e "${GREEN}–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ: ${BOLD}${TITLE}${RESET}"
        echo -e "–í—Å–µ–≥–æ —Ñ–∞–π–ª–æ–≤: ${CYAN}${total_count}${RESET}"; echo ""

        local loop_limit=$show_limit
        if [[ $loop_limit -gt $total_count ]]; then loop_limit=$total_count; fi

        for (( i=0; i<loop_limit; i++ )); do
            local file="${sorted_backups[$i]}"
            local filename=$(basename "$file")
            
            local CACHE_FILE="${file}.version"
            local B_VER=""
            if [[ -f "$CACHE_FILE" ]]; then B_VER=$(cat "$CACHE_FILE")
            else
                if [[ "$file" != *".enc" ]]; then
                    B_VER=$(tar -xzf "$file" -O bot_version.txt 2>/dev/null)
                fi
                if [[ -n "$B_VER" ]]; then echo "$B_VER" > "$CACHE_FILE"; else echo "?" > "$CACHE_FILE"; B_VER="?"; fi
            fi
            
            local ENC_MARK=""; [[ "$file" == *".enc" ]] && ENC_MARK="${RED}[ENC]${RESET} "
            
            local VER_STR=""
            if [[ "$B_VER" == "Unknown" || "$B_VER" == "" ]]; then VER_STR="${GRAY}[–ù/–î]${RESET}"
            elif [[ "$B_VER" == "?" ]]; then VER_STR="${GRAY}[Legacy]${RESET}"
            elif [[ -z "$CURRENT_VER" ]]; then VER_STR="${GRAY}[v$B_VER]${RESET}"
            elif [[ "$B_VER" == "$CURRENT_VER" ]]; then VER_STR="${GREEN}[v$B_VER]${RESET}"
            else VER_STR="${RED}[v$B_VER]${RESET}"; fi

            if [[ "$show_filenames" == "true" ]]; then
                printf " %2d. %s%s %s\n" "$((i+1))" "$ENC_MARK" "$filename" "$VER_STR"
            else
                if [[ $filename =~ _([0-9]{4}-[0-9]{2}-[0-9]{2})_([0-9]{2})_([0-9]{2}) ]]; then
                    local date_part="${BASH_REMATCH[1]}"
                    local time_part="${BASH_REMATCH[2]}:${BASH_REMATCH[3]}"
                    local d_d=${date_part:8:2}; local d_m=${date_part:5:2}
                    local pretty_date="$d_d.$d_m $time_part"
                    local fsize=$(du -h "$file" | awk '{print $1}')
                    printf " %2d. %s | %5s | %s%s\n" "$((i+1))" "${BOLD}$pretty_date${RESET}" "$fsize" "$ENC_MARK" "$VER_STR"
                else
                    printf " %2d. %s %s\n" "$((i+1))" "$filename" "$VER_STR"
                fi
            fi
        done

        echo ""
        if [[ $total_count -gt 5 ]]; then
            if [[ $loop_limit -lt $total_count ]]; then
                 echo -e " ${MAGENTA}6. –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ ($((total_count - 5)) —à—Ç)...${RESET}"
            else
                 echo -e " ${MAGENTA}6. –°–≤–µ—Ä–Ω—É—Ç—å —Å–ø–∏—Å–æ–∫ (–ø–æ–∫–∞–∑–∞—Ç—å 5)${RESET}"
            fi
        fi

        if [[ "$show_filenames" == "false" ]]; then
            echo -e " 7. –ü–æ–∫–∞–∑–∞—Ç—å –∏–º–µ–Ω–∞ —Ñ–∞–π–ª–æ–≤"; 
        else
            echo -e " 7. –ü–æ–∫–∞–∑–∞—Ç—å –¥–∞—Ç—É –∏ —Ä–∞–∑–º–µ—Ä"; 
        fi
        echo " 0. –ù–∞–∑–∞–¥"; echo ""
        read -erp "–ù–æ–º–µ—Ä (Enter - –ù–∞–∑–∞–¥): " choice
        
        if [[ -z "$choice" || "$choice" == "0" ]]; then return 1
        elif [[ "$choice" == "6" ]]; then 
            if [[ $loop_limit -lt $total_count ]]; then loop_limit=$total_count; else loop_limit=5; fi
            show_limit=$loop_limit
            continue
        elif [[ "$choice" == "7" ]]; then 
            if [[ "$show_filenames" == "false" ]]; then show_filenames=true; else show_filenames=false; fi
            continue
        elif [[ "$choice" =~ ^[0-9]+$ && "$choice" -le "$total_count" ]]; then SELECTED_FILE="${sorted_backups[$((choice-1))]}"; return 0
        else print_message "ERROR" "–ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä."; sleep 1; fi
    done
}

execute_restore() {
    local MODE="$1"; local FILE="$2"
    echo ""; print_message "WARN" "–í–ù–ò–ú–ê–ù–ò–ï: –¢–µ–∫—É—â–∏–µ –¥–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞–Ω—ã!"
    read -erp "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å? (y/n): " confirm; [[ "$confirm" != "y" ]] && return

    local TMP_DIR="$BACKUP_DIR/restore_tmp_$$"
    mkdir -p "$TMP_DIR"
    
    local WORK_FILE="$FILE"
    if [[ "$FILE" == *".enc" ]]; then
        print_message "INFO" "–§–∞–π–ª –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω. –¢—Ä–µ–±—É–µ—Ç—Å—è –ø–∞—Ä–æ–ª—å."
        read -s -erp "–ü–∞—Ä–æ–ª—å: " decrypt_pass; echo ""
        local DECRYPTED_FILE="$TMP_DIR/decrypted.tar.gz"
        
        export LAZARUS_DEC_PASS="$decrypt_pass"
        openssl enc -d -aes-256-cbc -pbkdf2 -in "$FILE" -out "$DECRYPTED_FILE" -pass env:LAZARUS_DEC_PASS 2>/dev/null
        local dec_res=$?
        unset LAZARUS_DEC_PASS

        if [[ $dec_res -ne 0 ]]; then print_message "ERROR" "–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å –∏–ª–∏ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–Ω—ã–π —Ñ–∞–π–ª!"; rm -rf "$TMP_DIR"; return; fi
        print_message "SUCCESS" "–ü–∞—Ä–æ–ª—å –ø—Ä–∏–Ω—è—Ç."
        WORK_FILE="$DECRYPTED_FILE"
    fi

    print_message "INFO" "–†–∞—Å–ø–∞–∫–æ–≤–∫–∞..."
    tar -xzf "$WORK_FILE" -C "$TMP_DIR"

    local DB_DUMP=$(find "$TMP_DIR" -name "db_*.sql.gz" | head -1)
    local DIR_ARC=$(find "$TMP_DIR" -name "dir_*.tar.gz" | head -1)

    if [[ "$MODE" == "full" && -n "$DIR_ARC" ]]; then
        if ! ensure_bot_path; then rm -rf "$TMP_DIR"; return; fi
        print_message "INFO" "–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤..."
        cd "$BOT_PATH" && docker compose down 2>/dev/null
        print_message "INFO" "–û—á–∏—Å—Ç–∫–∞ –ø–∞–ø–∫–∏..."
        rm -rf "$BOT_PATH"/*
        print_message "INFO" "–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ñ–∞–π–ª–æ–≤..."
        tar -xzf "$DIR_ARC" -C "$(dirname "$BOT_PATH")"
        docker volume rm "$DB_VOLUME_NAME" 2>/dev/null || true
        print_message "INFO" "–ó–∞–ø—É—Å–∫ –ë–î..."
        docker compose up -d "$DB_SERVICE_NAME"
        sleep 5
    fi

    if [[ -n "$DB_DUMP" ]]; then
        print_message "INFO" "–ò–º–ø–æ—Ä—Ç –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö..."
        if ! ensure_bot_path; then rm -rf "$TMP_DIR"; return; fi 
        zcat "$DB_DUMP" | docker exec -i "$DB_CONTAINER_NAME" psql -U "$DB_USER" -d postgres >/dev/null 2>&1
    fi

    if [[ "$MODE" == "full" ]]; then
        print_message "INFO" "–ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤..."
        cd "$BOT_PATH" && docker compose up -d
    fi

    rm -rf "$TMP_DIR"
    print_message "SUCCESS" "–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ."
    log_message "SUCCESS" "Restore completed (mode=$MODE, file=$FILE)"
    read -erp "–ù–∞–∂–º–∏—Ç–µ Enter..." dummy
}

# --- –ú–ï–ù–Æ–®–ö–ò ---

menu_manual_backup() {
    while true; do
        clear; echo -e "${GREEN}–°–æ–∑–¥–∞–Ω–∏–µ —Ä—É—á–Ω–æ–≥–æ –±—ç–∫–∞–ø–∞${RESET}"
        echo " 1. –ü–æ–ª–Ω—ã–π –±—ç–∫–∞–ø (–ë–î + –§–∞–π–ª—ã)"
        echo " 2. –¢–æ–ª—å–∫–æ –ë–∞–∑–∞ –î–∞–Ω–Ω—ã—Ö"
        echo " 3. –¢–æ–ª—å–∫–æ –§–∞–π–ª—ã"
        echo " 0. –ù–∞–∑–∞–¥"
        echo ""
        read -erp "–í–∞—à –≤—ã–±–æ—Ä (Enter - –ù–∞–∑–∞–¥): " m_choice
        [[ -z "$m_choice" ]] && return
        case $m_choice in
            1) create_backup "full"; read -erp "Enter..." dummy; return ;;
            2) create_backup "db_only"; read -erp "Enter..." dummy; return ;;
            3) create_backup "files_only"; read -erp "Enter..." dummy; return ;;
            0) return ;;
        esac
    done
}

menu_restore() {
    while true; do
        # –°–¢–†–û–ì–ê–Ø –õ–û–ì–ò–ö–ê –ü–û–î–°–ß–ï–¢–ê
        local n_full=$(find "$BACKUP_DIR" -type f \( -name "lazarus_full_*.tar.gz" -o -name "lazarus_full_*.tar.gz.enc" \) 2>/dev/null | wc -l)
        local n_db=$(find "$BACKUP_DIR" -type f \( -name "lazarus_db_*.tar.gz" -o -name "lazarus_db_*.tar.gz.enc" \) 2>/dev/null | wc -l)
        local n_files=$(find "$BACKUP_DIR" -type f \( -name "lazarus_files_*.tar.gz" -o -name "lazarus_files_*.tar.gz.enc" \) 2>/dev/null | wc -l)

        local c_f="$CYAN"; [[ "$n_full" == "0" ]] && c_f="$GRAY"
        local c_d="$CYAN"; [[ "$n_db" == "0" ]] && c_d="$GRAY"
        local c_fl="$CYAN"; [[ "$n_files" == "0" ]] && c_fl="$GRAY"

        clear; echo -e "${GREEN}–ú–µ–Ω—é –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è${RESET}"
        echo -e " 1. –ü–æ–ª–Ω—ã–π –±—ç–∫–∞–ø      ${c_f}[${n_full} —à—Ç]${RESET}"
        echo -e " 2. –¢–æ–ª—å–∫–æ –ë–∞–∑–∞       ${c_d}[${n_db} —à—Ç]${RESET}"
        echo -e " 3. –¢–æ–ª—å–∫–æ –§–∞–π–ª—ã      ${c_fl}[${n_files} —à—Ç]${RESET}"
        echo " 0. –ù–∞–∑–∞–¥"
        echo ""
        read -erp "–í—ã–±–æ—Ä (Enter - –ù–∞–∑–∞–¥): " r_choice
        [[ -z "$r_choice" ]] && return

        local SELECTED_FILE=""
        case $r_choice in
            1) if select_backup_file "lazarus_full" "–ü–æ–ª–Ω—ã–µ –±—ç–∫–∞–ø—ã"; then execute_restore "full" "$SELECTED_FILE"; fi ;;
            2) if select_backup_file "lazarus_db" "–ë—ç–∫–∞–ø—ã –ë–î"; then execute_restore "db_only" "$SELECTED_FILE"; fi ;;
            3) if select_backup_file "lazarus_files" "–ë—ç–∫–∞–ø—ã –§–∞–π–ª–æ–≤"; then 
                   echo ""; print_message "WARN" "–ë—É–¥—É—Ç –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞–Ω—ã —Ñ–∞–π–ª—ã –≤ –ø–∞–ø–∫–µ –±–æ—Ç–∞!"
                   read -erp "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å? (y/n): " cf
                   if [[ "$cf" == "y" ]]; then 
                       if ensure_bot_path; then tar -xzf "$SELECTED_FILE" -C "$(dirname "$BOT_PATH")"; print_message "SUCCESS" "–§–∞–π–ª—ã —Ä–∞—Å–ø–∞–∫–æ–≤–∞–Ω—ã."; read -erp "Enter..." dummy; fi
                   fi
               fi ;;
            0) return ;;
        esac
    done
}

setup_cron_task() {
    local TASK_TYPE="$1"; local JOB_CMD=""; local JOB_ID=""
    if [[ "$TASK_TYPE" == "db" ]]; then JOB_CMD="$SYMLINK_PATH backup_db"; JOB_ID="# LAZARUS-JOB-DB"
    elif [[ "$TASK_TYPE" == "files" ]]; then if ! ensure_bot_path; then return; fi; JOB_CMD="$SYMLINK_PATH backup_files"; JOB_ID="# LAZARUS-JOB-FILES"
    elif [[ "$TASK_TYPE" == "full" ]]; then if ! ensure_bot_path; then return; fi; JOB_CMD="$SYMLINK_PATH backup_full"; JOB_ID="# LAZARUS-JOB-FULL"; fi

    clear; echo -e "${GREEN}–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–µ—Ä–∏–æ–¥–∞: ${BOLD}${TASK_TYPE^^}${RESET}"
    echo " 1. –ï–∂–µ—á–∞—Å–Ω–æ"
    echo " 2. –ï–∂–µ–¥–Ω–µ–≤–Ω–æ (04:00)"
    echo " 3. –ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ"
    echo " 4. –°–≤–æ–µ –≤—Ä–µ–º—è"
    echo " 5. –ö–∞–∂–¥—ã–µ N –º–∏–Ω—É—Ç"
    echo " 6. –û—Ç–∫–ª—é—á–∏—Ç—å"
    echo ""
    read -erp "–í—ã–±–æ—Ä (Enter - –ù–∞–∑–∞–¥): " c
    [[ -z "$c" ]] && return
    
    local NEW_CRON_LINES=""; local DISPLAY_TIME=""

    case $c in
        1) NEW_CRON_LINES="0 * * * * $JOB_CMD >> /var/log/lazarus_backup.log 2>&1 $JOB_ID"; DISPLAY_TIME="–ï–∂–µ—á–∞—Å–Ω–æ" ;;
        2) NEW_CRON_LINES="0 4 * * * $JOB_CMD >> /var/log/lazarus_backup.log 2>&1 $JOB_ID"; DISPLAY_TIME="–ï–∂–µ–¥–Ω–µ–≤–Ω–æ 04:00" ;;
        3) NEW_CRON_LINES="0 4 * * 1 $JOB_CMD >> /var/log/lazarus_backup.log 2>&1 $JOB_ID"; DISPLAY_TIME="–ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ" ;;
        4) echo "–í—Ä–µ–º—è (–ß–ß:–ú–ú) —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª:"; read -erp "> " times_input
           if [[ -z "$times_input" ]]; then print_message "ERROR" "–í—Ä–µ–º—è –Ω–µ –≤–≤–µ–¥–µ–Ω–æ!"; sleep 1; return; fi
           for t in $times_input; do if [[ "$t" =~ ^([0-9]{1,2}):([0-9]{1,2})$ ]]; then h=$((10#${BASH_REMATCH[1]})); m=$((10#${BASH_REMATCH[2]})); NEW_CRON_LINES+="$m $h * * * $JOB_CMD >> /var/log/lazarus_backup.log 2>&1 $JOB_ID"$'\n'; fi; done; DISPLAY_TIME="–°–≤–æ–µ: $times_input" ;;
        5) read -erp "–í–≤–µ–¥–∏—Ç–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª (–º–∏–Ω—É—Ç): " interval
           if [[ "$interval" =~ ^[0-9]+$ ]] && [ "$interval" -gt 0 ] && [ "$interval" -lt 60 ]; then
               NEW_CRON_LINES="*/$interval * * * * $JOB_CMD >> /var/log/lazarus_backup.log 2>&1 $JOB_ID"
               DISPLAY_TIME="–ö–∞–∂–¥—ã–µ $interval –º–∏–Ω"
           else print_message "ERROR" "–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 59."; sleep 1; return; fi ;;
        6) DISPLAY_TIME="–í—ã–∫–ª" ;;
        *) return ;;
    esac

    local CURRENT_CRON=$(crontab -l 2>/dev/null | grep -v "$JOB_ID")
    if [[ "$DISPLAY_TIME" != "–í—ã–∫–ª" && -n "$NEW_CRON_LINES" ]]; then echo -e "$CURRENT_CRON\n$NEW_CRON_LINES" | crontab -
    else echo "$CURRENT_CRON" | crontab -; fi

    if [[ "$TASK_TYPE" == "full" ]]; then SCHEDULE_FULL="$DISPLAY_TIME"; fi
    if [[ "$TASK_TYPE" == "db" ]];   then SCHEDULE_DB="$DISPLAY_TIME"; fi
    if [[ "$TASK_TYPE" == "files" ]]; then SCHEDULE_FILES="$DISPLAY_TIME"; fi
    save_config; print_message "SUCCESS" "–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ!"; sleep 1
}

menu_automation() {
    while true; do
        clear; echo -e "${GREEN}–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ë–µ–∫–∞–ø–∞${RESET}"
        echo -e " 1. –ü–æ–ª–Ω—ã–π –±—ç–∫–∞–ø [${YELLOW}${SCHEDULE_FULL}${RESET}]"
        echo -e " 2. –¢–æ–ª—å–∫–æ –ë–∞–∑–∞  [${YELLOW}${SCHEDULE_DB}${RESET}]"
        echo -e " 3. –¢–æ–ª—å–∫–æ –§–∞–π–ª—ã [${YELLOW}${SCHEDULE_FILES}${RESET}]"
        echo " 0. –ù–∞–∑–∞–¥"
        echo ""
        read -erp "–í—ã–±–æ—Ä (Enter - –ù–∞–∑–∞–¥): " ac
        [[ -z "$ac" ]] && return
        case $ac in 1) setup_cron_task "full" ;; 2) setup_cron_task "db" ;; 3) setup_cron_task "files" ;; 0) return ;; esac
    done
}

menu_settings() {
    while true; do
        clear; echo -e "${GREEN}–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–∫—Ä–∏–ø—Ç–∞${RESET}"
        
        local MASKED_TOKEN="${BOT_TOKEN:0:5}.......${BOT_TOKEN: -5}"; [[ ${#BOT_TOKEN} -lt 10 ]] && MASKED_TOKEN="*******"
        local PASS_MASK="–ù–µ—Ç"; [[ -n "$BACKUP_PASSWORD" ]] && PASS_MASK="********"
        
        local MASKED_REMOTE_USER="-"
        if [[ -n "$REMOTE_STORAGE_USER" ]]; then
            if [[ ${#REMOTE_STORAGE_USER} -gt 4 ]]; then
                MASKED_REMOTE_USER="${REMOTE_STORAGE_USER:0:3}...${REMOTE_STORAGE_USER: -2}"
            else
                MASKED_REMOTE_USER="*****"
            fi
        fi

        local ST_TG="${RED}–í—ã–∫–ª${RESET}"; [[ "$SEND_TO_TELEGRAM" == "true" ]] && ST_TG="${GREEN}–í–∫–ª${RESET}"
        local ST_REM="${RED}–í—ã–∫–ª${RESET}"; [[ "$SEND_TO_REMOTE" == "true" ]] && ST_REM="${GREEN}–í–∫–ª${RESET}"
        
        local STORAGE_TYPE_DISP="–í—ã–∫–ª"
        if [[ "$REMOTE_STORAGE_TYPE" != "off" ]]; then STORAGE_TYPE_DISP="${REMOTE_STORAGE_TYPE^^}"; fi

        echo -e "${CYAN}--- –û–ë–©–ò–ï ---${RESET}"
        echo -e " 1. –ü—É—Ç—å –∫ –±–æ—Ç—É:      ${GRAY}${BOT_PATH}${RESET}"
        echo -e " 2. –ò–º—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞:   ${GRAY}${BOT_CONTAINER_NAME}${RESET}"
        echo -e " 3. –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –ë–î:     ${GRAY}${DB_CONTAINER_NAME}${RESET}"
        echo -e " 4. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ë–î:  ${GRAY}${DB_USER}${RESET}"
        echo -e " 5. –•—Ä–∞–Ω–∏—Ç—å –±—ç–∫–∞–ø—ã:   ${GRAY}${MAX_BACKUPS_COUNT} —à—Ç.${RESET}"
        echo -e " 6. –ò—Å–∫–ª—é—á–∏—Ç—å –ø–∞–ø–∫–∏:  ${GRAY}${EXCLUDE_DIRS:-–ù–µ—Ç}${RESET}"
        echo -e " 7. –ú–∞–∫—Å. —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞: ${GRAY}${MAX_FILE_SIZE_MB} MB${RESET}"
        
        echo -e "\n${CYAN}--- TELEGRAM ($ST_TG) ---${RESET}"
        echo -e " 8. Token:            ${GRAY}${MASKED_TOKEN}${RESET}"
        echo -e " 9. Chat ID:          ${GRAY}${CHAT_ID}${RESET}"
        echo -e " 10. Thread ID:       ${GRAY}${TG_MESSAGE_THREAD_ID:-–ù–µ—Ç}${RESET}"
        echo -e " 11. –û—Ç–ø—Ä–∞–≤–∫–∞:        $ST_TG"
        echo -e " 12. ‚ö° –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–≤—è–∑—å (Telegram)"

        echo -e "\n${CYAN}--- –£–î–ê–õ–ï–ù–ù–û–ï –•–†–ê–ù–ò–õ–ò–©–ï ($ST_REM) ---${RESET}"
        echo -e " 13. –¢–∏–ø:             ${GRAY}${STORAGE_TYPE_DISP}${RESET}"
        echo -e " 14. URL:             ${GRAY}${REMOTE_STORAGE_URL:-–ù–µ—Ç}${RESET}"
        echo -e " 15. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:    ${GRAY}${MASKED_REMOTE_USER}${RESET}"
        echo -e " 16. –ü–∞—Ä–æ–ª—å:          ${GRAY}********${RESET}"
        echo -e " 17. –ó–∞–≥—Ä—É–∑–∫–∞:        $ST_REM"
        echo -e " 18. ‚ö° –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–≤—è–∑—å (–û–±–ª–∞–∫–æ)"

        echo -e "\n${CYAN}--- –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–¨ ---${RESET}"
        echo -e " 19. –ü–∞—Ä–æ–ª—å –∞—Ä—Ö–∏–≤–∞:   ${GRAY}${PASS_MASK}${RESET}"
    echo -e "\n${CYAN}--- –£–î–ê–õ–ï–ù–ò–ï –°–¢–ê–†–´–• –ë–≠–ö–ê–ü–û–í ---${RESET}"
    local DM_DISPLAY="$DELETE_MODE"
    if [[ "$DELETE_MODE" == "time" ]]; then DM_DISPLAY="–ü–æ –≤—Ä–µ–º–µ–Ω–∏"; else DM_DISPLAY="–ü–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É"; fi
    echo -e " 20. –†–µ–∂–∏–º —É–¥–∞–ª–µ–Ω–∏—è:  ${GRAY}${DM_DISPLAY}${RESET}"
    echo -e " 21. –°—Ä–æ–∫ —Ö—Ä–∞–Ω–µ–Ω–∏—è (–¥–Ω–µ–π): ${GRAY}${RETENTION_DAYS}${RESET}"
        
        echo -e "\n 0. –ù–∞–∑–∞–¥"
        echo ""
        read -erp "–ß—Ç–æ –∏–∑–º–µ–Ω–∏—Ç—å (–Ω–æ–º–µ—Ä): " s
        [[ -z "$s" ]] && return
        
        case $s in
            1) read -erp "–ù–æ–≤—ã–π –ø—É—Ç—å: " np; if [[ -n "$np" ]]; then if [[ -d "$np" ]]; then BOT_PATH="$np"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"; else print_message "ERROR" "–ü–∞–ø–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!"; fi; fi ;;
            
            2) 
                scan_system_for_bot
                local def_cont="${FOUND_BOT:-$BOT_CONTAINER_NAME}"
                local prompt_msg="–ò–º—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –±–æ—Ç–∞"
                [[ -n "$FOUND_BOT" ]] && prompt_msg+=" (Enter = '$FOUND_BOT')"
                read -erp "$prompt_msg: " nc; nc="${nc:-$def_cont}"
                if [[ -n "$nc" ]]; then BOT_CONTAINER_NAME="$nc"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"; fi ;;
                
            3) 
                scan_system_for_bot
                local def_db="${FOUND_DB:-$DB_CONTAINER_NAME}"
                local prompt_msg="–ò–º—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –ë–î"
                [[ -n "$FOUND_DB" ]] && prompt_msg+=" (Enter = '$FOUND_DB')"
                read -erp "$prompt_msg: " ndb_c; ndb_c="${ndb_c:-$def_db}"
                if [[ -n "$ndb_c" ]]; then DB_CONTAINER_NAME="$ndb_c"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"; fi ;;

            4) read -erp "–ù–æ–≤—ã–π DB User: " ndb; if [[ -n "$ndb" ]]; then DB_USER="$ndb"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"; fi ;;
            5) read -erp "–ú–∞–∫—Å. –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±—ç–∫–∞–ø–æ–≤: " nd; if [[ "$nd" =~ ^[0-9]+$ ]]; then MAX_BACKUPS_COUNT="$nd"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"; fi ;;
            6) read -erp "–ò—Å–∫–ª—é—á–∏—Ç—å (–Ω–∞–ø—Ä–∏–º–µ—Ä: uploads/cache): " ed; if [[ -n "$ed" ]]; then EXCLUDE_DIRS="$ed"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"; else if [[ -n "$EXCLUDE_DIRS" ]]; then read -erp "–û—á–∏—Å—Ç–∏—Ç—å? (y/N): " clr; if [[ "$clr" =~ ^[Yy]$ ]]; then EXCLUDE_DIRS=""; save_config; fi; fi; fi ;;
            7) read -erp "–ú–∞–∫—Å. —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –≤ MB: " msize; if [[ "$msize" =~ ^[0-9]+$ ]] && [ "$msize" -gt 0 ]; then MAX_FILE_SIZE_MB="$msize"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"; fi ;;
            
            8) read -erp "–ù–æ–≤—ã–π Token: " nt; if [[ -n "$nt" ]]; then BOT_TOKEN="$nt"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"; fi ;;
            9) read -erp "–ù–æ–≤—ã–π Chat ID: " nid; if [[ -n "$nid" ]]; then CHAT_ID="$nid"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"; fi ;;
            10) read -erp "–ù–æ–≤—ã–π Thread ID: " ntid; TG_MESSAGE_THREAD_ID="$ntid"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ" ;;
            11) if [[ "$SEND_TO_TELEGRAM" == "true" ]]; then SEND_TO_TELEGRAM="false"; else SEND_TO_TELEGRAM="true"; fi; save_config; ;;
            12) test_telegram_connection ;;

            13) configure_remote_storage ;; 
            14) configure_remote_storage ;; 
            15) configure_remote_storage ;; 
            16) configure_remote_storage ;; 
            17) if [[ "$SEND_TO_REMOTE" == "true" ]]; then SEND_TO_REMOTE="false"; else SEND_TO_REMOTE="true"; fi; save_config; ;;
            18) if [[ "$REMOTE_STORAGE_TYPE" != "off" ]]; then validate_remote_connection "$REMOTE_STORAGE_TYPE" "$REMOTE_STORAGE_URL" "$REMOTE_STORAGE_USER" "$REMOTE_STORAGE_PASS"; if [[ $? -eq 0 ]]; then print_message "SUCCESS" "–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ OK"; else print_message "ERROR" "–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"; fi; read -erp "Enter..." d; else print_message "WARN" "–•—Ä–∞–Ω–∏–ª–∏—â–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ"; sleep 1; fi ;;

            19) read -s -erp "–ù–æ–≤—ã–π –ø–∞—Ä–æ–ª—å —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è (Enter - —Å–±—Ä–æ—Å–∏—Ç—å): " new_pass; echo ""
                BACKUP_PASSWORD="$new_pass"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ." ;;
            20)
                echo "–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º —É–¥–∞–ª–µ–Ω–∏—è —Å—Ç–∞—Ä—ã—Ö –±—ç–∫–∞–ø–æ–≤:"; echo " 1) –ü–æ –≤—Ä–µ–º–µ–Ω–∏ (days)"; echo " 2) –ü–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É (count)"
                read -erp "–í—ã–±–æ—Ä (1/2): " dm
                if [[ "$dm" == "1" ]]; then DELETE_MODE="time"; else DELETE_MODE="count"; fi
                save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ" ;;
            21)
                read -erp "–í–≤–µ–¥–∏—Ç–µ —Å—Ä–æ–∫ —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –¥–Ω—è—Ö (—á–∏—Å–ª–æ): " ndays
                if [[ "$ndays" =~ ^[0-9]+$ ]] && [ "$ndays" -ge 0 ]; then RETENTION_DAYS="$ndays"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"; else print_message "ERROR" "–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ"; fi ;;
            
            0) return ;;
        esac; if [[ -n "$s" ]]; then sleep 0.5; fi
    done
}

cleanup_old_backups() {
    clear; echo -e "${RED}–û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –±—ç–∫–∞–ø–æ–≤${RESET}"
    
    local del_full=0; local del_db=0; local del_files=0

    echo -e "–¢–µ–∫—É—â–∏–π —Ä–µ–∂–∏–º –æ—á–∏—Å—Ç–∫–∏: ${YELLOW}$DELETE_MODE${RESET}"
    if [[ "$DELETE_MODE" == "count" ]]; then
        echo "–õ–∏–º–∏—Ç —Ö—Ä–∞–Ω–µ–Ω–∏—è: $MAX_BACKUPS_COUNT —à—Ç."
        echo ""
        del_full=$(rotate_backups_by_count "lazarus_full" "–ü–æ–ª–Ω—ã–µ –±—ç–∫–∞–ø—ã" "false" | tail -n1)
        del_db=$(rotate_backups_by_count "lazarus_db" "–ë–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö" "false" | tail -n1)
        del_files=$(rotate_backups_by_count "lazarus_files" "–ê—Ä—Ö–∏–≤—ã —Ñ–∞–π–ª–æ–≤" "false" | tail -n1)
    else
        # time-based
        echo -e " –°—Ä–æ–∫ —Ö—Ä–∞–Ω–µ–Ω–∏—è (–¥–Ω–µ–π): ${YELLOW}$RETENTION_DAYS${RESET}"
        echo ""
        del_full=$(rotate_backups_by_age "lazarus_full" "–ü–æ–ª–Ω—ã–µ –±—ç–∫–∞–ø—ã" "$RETENTION_DAYS" "false" | tail -n1)
        del_db=$(rotate_backups_by_age "lazarus_db" "–ë–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö" "$RETENTION_DAYS" "false" | tail -n1)
        del_files=$(rotate_backups_by_age "lazarus_files" "–ê—Ä—Ö–∏–≤—ã —Ñ–∞–π–ª–æ–≤" "$RETENTION_DAYS" "false" | tail -n1)
    fi

    echo ""
    # normalize empty to 0
    del_full=${del_full:-0}; del_db=${del_db:-0}; del_files=${del_files:-0}
    local total_del=$((del_full + del_db + del_files))

    if [[ "$total_del" -eq 0 ]]; then
        print_message "SUCCESS" "–ß–∏—Å—Ç–∫–∞ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è. –í—Å–µ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –ª–∏–º–∏—Ç–∞."
        read -erp "Enter..." dummy
        return
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        print_message "WARN" "[DRY-RUN] –ö–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –Ω–∞ —É–¥–∞–ª–µ–Ω–∏–µ: $total_del"
    else
        print_message "WARN" "–ë—É–¥–µ—Ç —É–¥–∞–ª–µ–Ω–æ —Å—Ç–∞—Ä—ã—Ö –∞—Ä—Ö–∏–≤–æ–≤: $total_del"
    fi
    # support non-interactive auto-confirm
    if [[ "$AUTO_CONFIRM" == "true" ]]; then
        confirm="y"
    else
        read -erp "–£–¥–∞–ª–∏—Ç—å —ç—Ç–∏ —Ñ–∞–π–ª—ã? (y/N): " confirm
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        # In dry-run we never delete
        log_message "INFO" "[DRY_RUN] Cleanup preview (mode=$DELETE_MODE, retention_days=$RETENTION_DAYS, max_count=$MAX_BACKUPS_COUNT, candidates=$total_del)"
        if [[ "$REPORT_TO_TG" == "true" && "$SEND_TO_TELEGRAM" == "true" ]]; then
            send_telegram_text "$(escape_markdown_v2 "üßπ DRY-RUN –æ—á–∏—Å—Ç–∫–∞: –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤=$total_del, mode=$DELETE_MODE")"
        fi
        read -erp "Enter..." dummy
        return
    fi

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        echo ""
        if [[ "$DELETE_MODE" == "count" ]]; then
            rotate_backups_by_count "lazarus_full" "–ü–æ–ª–Ω—ã–µ –±—ç–∫–∞–ø—ã" "true" >/dev/null
            rotate_backups_by_count "lazarus_db" "–ë–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö" "true" >/dev/null
            rotate_backups_by_count "lazarus_files" "–ê—Ä—Ö–∏–≤—ã —Ñ–∞–π–ª–æ–≤" "true" >/dev/null
        else
            rotate_backups_by_age "lazarus_full" "–ü–æ–ª–Ω—ã–µ –±—ç–∫–∞–ø—ã" "$RETENTION_DAYS" "true" >/dev/null
            rotate_backups_by_age "lazarus_db" "–ë–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö" "$RETENTION_DAYS" "true" >/dev/null
            rotate_backups_by_age "lazarus_files" "–ê—Ä—Ö–∏–≤—ã —Ñ–∞–π–ª–æ–≤" "$RETENTION_DAYS" "true" >/dev/null
        fi
        echo ""; print_message "SUCCESS" "–û—á–∏—Å—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞."
        log_message "INFO" "Cleanup completed (mode=$DELETE_MODE, retention_days=$RETENTION_DAYS, max_count=$MAX_BACKUPS_COUNT, deleted=$total_del)"
        if [[ "$REPORT_TO_TG" == "true" && "$SEND_TO_TELEGRAM" == "true" ]]; then
            send_telegram_text "$(escape_markdown_v2 "üßπ –û—á–∏—Å—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞: —É–¥–∞–ª–µ–Ω–æ=$total_del, mode=$DELETE_MODE")"
        fi
    else
        echo ""; print_message "INFO" "–û—Ç–º–µ–Ω–µ–Ω–æ."
    fi
    read -erp "Enter..." dummy
}

# --- MAIN LOOP ---
rotate_internal_log
check_dependencies
install_script
load_or_create_config
check_config_mismatch # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
# --- Global CLI flags parsing ---
# Support calling like: lazarus --yes --dry-run cleanup
DRY_RUN="false"
REPORT_TO_TG="false"

# Build new argv stripping known global flags
_NEWARGS=()
for _a in "$@"; do
    case "$_a" in
        --yes|-y) AUTO_CONFIRM="true" ;;
        --dry-run|-n) DRY_RUN="true" ;;
        --report-tg) REPORT_TO_TG="true" ;;
        *) _NEWARGS+=("$_a") ;;
    esac
done
set -- "${_NEWARGS[@]}"

case "$1" in
    backup_full) create_backup "full" ;;
    backup_db)   create_backup "db_only" ;;
    backup_files) create_backup "files_only" ;;
    cleanup|cleanup_old_backups)
        cleanup_old_backups ;;
    restore) menu_restore ;;
    check_update) check_for_updates ;;
    *)
        while true; do
            BOT_VERSION=$(get_bot_version_display)
            clear
            echo -e "${GREEN}${BOLD}LAZARUS Backup Manager v${VERSION}${RESET}"
            echo -e "–í–µ—Ä—Å–∏—è –±–æ—Ç–∞: ${CYAN}${BOT_VERSION}${RESET}"
            echo ""
            echo -e "–°—Ç–∞—Ç—É—Å—ã –∞–≤—Ç–æ-–±–µ–∫–∞–ø–∞:"
            echo -e " ‚Ä¢ Full:  ${YELLOW}${SCHEDULE_FULL}${RESET}"
            echo -e " ‚Ä¢ DB:    ${YELLOW}${SCHEDULE_DB}${RESET}"
            echo -e " ‚Ä¢ Files: ${YELLOW}${SCHEDULE_FILES}${RESET}"
            echo ""
            echo " --- –î–ï–ô–°–¢–í–ò–Ø ---"
            echo " 1. –†—É—á–Ω–æ–π –±–µ–∫–∞–ø (Full / DB / Files)"
            echo " 2. –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –∞–≤—Ç–æ-–±–µ–∫–∞–ø"
            echo " 3. –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∏–∑ –±—ç–∫–∞–ø–∞"
            echo " 4. –ù–∞—Å—Ç—Ä–æ–π–∫–∏ (–ü—É—Ç–∏ / –¢–æ–∫–µ–Ω—ã / –†–æ—Ç–∞—Ü–∏—è)"
            
            CLEANUP_LABEL=""
            if [[ "$DELETE_MODE" == "time" ]]; then
                CLEANUP_LABEL="(>$RETENTION_DAYS –¥–Ω–µ–π)"
            else
                CLEANUP_LABEL="(>$MAX_BACKUPS_COUNT —à—Ç.)"
            fi
            echo " 5. –£–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä—ã–µ –±—ç–∫–∞–ø—ã $CLEANUP_LABEL"
            echo ""
            echo -e " 8. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è"
            echo -e "${RED} 666. –£–¥–∞–ª–∏—Ç—å —Å–∫—Ä–∏–ø—Ç (Uninstall)${RESET}"
            echo " 0. –í—ã—Ö–æ–¥"
            echo ""
            read -erp "–í—ã–±–æ—Ä (Enter - –≤—ã—Ö–æ–¥): " opt; [[ -z "$opt" ]] && exit 0
            case $opt in
                1) menu_manual_backup ;; 2) menu_automation ;; 3) menu_restore ;; 
                4) menu_settings ;; 5) cleanup_old_backups ;; 8) check_for_updates ;; 666) uninstall_script ;; 0) exit 0 ;;
            esac
        done
        ;;
esac
