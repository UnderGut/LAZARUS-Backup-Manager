#!/bin/bash

# --- –ù–ê–°–¢–†–û–ô–ö–ò ---
VERSION="4.15.0"
SCRIPT_NAME="lazarus"
INSTALL_DIR="/opt/lazarus-backup"
BACKUP_DIR="$INSTALL_DIR/backup"
CONFIG_FILE="$INSTALL_DIR/config.env"
SYMLINK_PATH="/usr/local/bin/$SCRIPT_NAME"
REMOTE_URL="https://raw.githubusercontent.com/UnderGut/LAZARUS-Backup-Manager/main/lazarus-backup"

# --- –ö–õ–Æ–ß–ï–í–´–ï –°–õ–û–í–ê –î–õ–Ø –ü–û–ò–°–ö–ê ---
KEYWORDS=("remnawave" "telegram-shop" "shop-bot" "shopbot")

# --- –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ---
BOT_PATH=""
BOT_TOKEN=""
CHAT_ID=""
TG_MESSAGE_THREAD_ID=""
DB_USER="postgres"
IGNORE_MISMATCH="false"
EXCLUDE_DIRS=""
MAX_FILE_SIZE_MB="1"

# –ü–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª–∏ –æ—Ç–ø—Ä–∞–≤–∫–∏
SEND_TO_TELEGRAM="true"      # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ Telegram
TG_SEND_FILE="true"          # –û—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–∞–π–ª–∞ –±—ç–∫–∞–ø–∞ –≤ Telegram
SEND_TO_REMOTE="true"

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ä–æ—Ç–∞—Ü–∏–∏ (–ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É)
MAX_BACKUPS_COUNT="100"

# –£–¥–∞–ª—è—Ç—å —Å—Ç–∞—Ä—ã–µ –±—ç–∫–∞–ø—ã: "time" –∏–ª–∏ "count" (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é time)
DELETE_MODE="time"
# –°—Ä–æ–∫ —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –¥–Ω—è—Ö –ø—Ä–∏ —Ä–µ–∂–∏–º–µ time (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 7 –¥–Ω–µ–π)
RETENTION_DAYS="7"

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞
REMOTE_STORAGE_TYPE="off" # off, ftp, webdav
REMOTE_STORAGE_URL=""
REMOTE_STORAGE_USER=""
REMOTE_STORAGE_PASS=""
REMOTE_UPLOAD_STATUS_TEXT=""

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
BACKUP_PASSWORD=""

# –ó–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
BOT_CONTAINER_NAME="" 
DB_CONTAINER_NAME=""
DEFAULT_BOT_PATH="/opt/private-remnawave-telegram-shop-bot"
DEFAULT_DB_NAME="remnawave-telegram-shop-db"
DB_VOLUME_NAME="remnawave-telegram-shop-db-data"
DB_SERVICE_NAME="db" 

# –°—Ç–∞—Ç—É—Å—ã —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–π
SCHEDULE_FULL="–í—ã–∫–ª"
SCHEDULE_DB="–í—ã–∫–ª"
SCHEDULE_FILES="–í—ã–∫–ª"

# –§–ª–∞–≥ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞
IS_INTERACTIVE=true
if [[ ! -t 0 ]]; then IS_INTERACTIVE=false; fi

# –†–µ–∂–∏–º –æ—Ç–ª–∞–¥–∫–∏ (--debug)
DEBUG_MODE=false

# –ê–≤—Ç–æ-–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –¥–ª—è –Ω–µ–∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, cron --yes)
AUTO_CONFIRM="false"

# –õ–æ–≥-—Ñ–∞–π–ª –¥–ª—è –ø–æ–¥—Ä–æ–±–Ω—ã—Ö –ª–æ–≥–æ–≤
LOG_FILE="/var/log/lazarus_backup.log"

# –¶–≤–µ—Ç–∞
if [[ -t 0 ]]; then
    RED=$'\e[31m'; GREEN=$'\e[32m'; YELLOW=$'\e[33m'; GRAY=$'\e[90m'; CYAN=$'\e[36m'; MAGENTA=$'\e[35m'; RESET=$'\e[0m'; BOLD=$'\e[1m'
else
    RED=""; GREEN=""; YELLOW=""; GRAY=""; CYAN=""; MAGENTA=""; RESET=""; BOLD=""
fi

# --- –§–£–ù–ö–¶–ò–ò –ò–ù–¢–ï–†–§–ï–ô–°–ê ---

# –û—á–∏—Å—Ç–∫–∞ —ç–∫—Ä–∞–Ω–∞ (–ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç—Å—è –≤ debug —Ä–µ–∂–∏–º–µ)
clear_screen() {
    if [[ "$DEBUG_MODE" == true ]]; then
        echo ""
        echo -e "${MAGENTA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê [DEBUG: clear skipped] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${RESET}"
        echo ""
    else
        clear
    fi
}

# –û—Ç–ª–∞–¥–æ—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
debug_log() {
    if [[ "$DEBUG_MODE" == true ]]; then
        echo -e "${MAGENTA}[DEBUG]${RESET} $1"
    fi
}

escape_markdown_v2() {
    echo "$1" | sed -e 's/\\/\\\\/g' -e 's/_/\\_/g' -e 's/\[/\\[/g' -e 's/\]/\\]/g' \
        -e 's/(/\\(/g' -e 's/)/\\)/g' -e 's/~/\~/g' -e 's/`/\\`/g' -e 's/>/\\>/g' \
        -e 's/#/\\#/g' -e 's/+/\\+/g' -e 's/-/\\-/g' -e 's/=/\\=/g' -e 's/|/\\|/g' \
        -e 's/{/\\{/g' -e 's/}/\\}/g' -e 's/\./\\./g' -e 's/!/\!/g'
}

send_telegram_notification() {
    local msg="$1"
    if [[ "$SEND_TO_TELEGRAM" == "true" && -n "$BOT_TOKEN" && -n "$CHAT_ID" ]]; then
        if command -v curl >/dev/null 2>&1; then
            local escaped_msg
            escaped_msg=$(escape_markdown_v2 "$msg")
            local thread_param=""
            [[ -n "$TG_MESSAGE_THREAD_ID" ]] && thread_param="-d message_thread_id=$TG_MESSAGE_THREAD_ID"
            
            curl -s -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" \
                -d chat_id="$CHAT_ID" \
                -d parse_mode="MarkdownV2" \
                -d text="üö® *Lazarus Error* üö®%0A%0A${escaped_msg}" \
                $thread_param >/dev/null 2>&1 || true
        fi
    fi
}

print_message() {
    local type="$1"; local message="$2"; local color_code="$RESET"
    case "$type" in
        "INFO") color_code="$GRAY" ;;
        "SUCCESS") color_code="$GREEN" ;;
        "WARN") color_code="$YELLOW" ;;
        "ERROR") color_code="$RED" ;;
        "ACTION") color_code="$CYAN" ;;
    esac
    echo -e "${color_code}[$type]${RESET} $message"

    if [[ "$type" == "ERROR" ]]; then
        send_telegram_notification "$message"
    fi
}

log_message() {
    # Level, Message
    local level="$1"; local message="$2"
    # Ensure log dir exists and file is writable
    local logdir
    logdir=$(dirname "$LOG_FILE")
    if [[ ! -d "$logdir" ]]; then mkdir -p "$logdir" 2>/dev/null || true; fi
    if [[ ! -f "$LOG_FILE" ]]; then touch "$LOG_FILE" 2>/dev/null || true; fi
    local ts
    ts=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$ts] [$level] $message" >> "$LOG_FILE" 2>/dev/null || true
}

rotate_internal_log() {
    # Rotate log if > 10MB
    local MAX_LOG_SIZE=$((10 * 1024 * 1024))
    if [[ -f "$LOG_FILE" ]]; then
        local size
        size=$(stat -c%s "$LOG_FILE" 2>/dev/null || echo 0)
        if [[ "$size" -gt "$MAX_LOG_SIZE" ]]; then
            mv "$LOG_FILE" "${LOG_FILE}.old"
            echo "Log rotated on $(date)" > "$LOG_FILE"
        fi
    fi
}

check_dependencies() {
    local deps=("tar" "gzip" "openssl" "docker" "find" "du" "date")
    local missing=()
    
    # Check for curl OR wget
    if ! command -v curl >/dev/null 2>&1 && ! command -v wget >/dev/null 2>&1; then
        missing+=("curl (or wget)")
    fi

    for cmd in "${deps[@]}"; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing+=("$cmd")
        fi
    done
    
    # Check for docker compose (v2)
    if command -v docker >/dev/null 2>&1; then
        if ! docker compose version >/dev/null 2>&1; then
             echo -e "${RED}[ERROR]${RESET} 'docker compose' plugin is required but not found."
             echo -e "${CYAN}[ACTION]${RESET} Please install docker-compose-plugin (v2)."
             exit 1
        fi
    fi

    if [[ ${#missing[@]} -gt 0 ]]; then
        echo -e "${RED}[ERROR]${RESET} Missing dependencies: ${missing[*]}"
        echo -e "${CYAN}[ACTION]${RESET} Please install them (e.g., apt install ${missing[*]})"
        exit 1
    fi
}

# --- –°–¢–ê–¢–ò–°–¢–ò–ö–ê –ë–≠–ö–ê–ü–û–í ---

get_backup_stats() {
    # –ü–æ–¥—Å—á—ë—Ç —Ñ–∞–π–ª–æ–≤ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
    local n_full=$(find "$BACKUP_DIR" -maxdepth 1 -type f \( -name "lazarus_full_*.tar.gz" -o -name "lazarus_full_*.tar.gz.enc" \) 2>/dev/null | wc -l)
    local n_db=$(find "$BACKUP_DIR" -maxdepth 1 -type f \( -name "lazarus_db_*.tar.gz" -o -name "lazarus_db_*.tar.gz.enc" \) 2>/dev/null | wc -l)
    local n_files=$(find "$BACKUP_DIR" -maxdepth 1 -type f \( -name "lazarus_files_*.tar.gz" -o -name "lazarus_files_*.tar.gz.enc" \) 2>/dev/null | wc -l)
    
    # –û–±—â–∏–π —Ä–∞–∑–º–µ—Ä –ø–∞–ø–∫–∏ –±—ç–∫–∞–ø–æ–≤
    local total_size="0B"
    if [[ -d "$BACKUP_DIR" ]]; then
        total_size=$(du -sh "$BACKUP_DIR" 2>/dev/null | awk '{print $1}')
    fi
    
    # –ü–æ—Å–ª–µ–¥–Ω–∏–π –±—ç–∫–∞–ø (–ª—é–±–æ–π —Ç–∏–ø)
    local last_backup=""
    local last_backup_ago=""
    local latest_file=$(find "$BACKUP_DIR" -maxdepth 1 -type f \( -name "lazarus_*.tar.gz" -o -name "lazarus_*.tar.gz.enc" \) -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -1 | awk '{print $2}')
    
    if [[ -n "$latest_file" && -f "$latest_file" ]]; then
        local filename=$(basename "$latest_file")
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞—Ç—É –∏–∑ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞: lazarus_type_YYYY-MM-DD_HH_MM_SS.tar.gz
        if [[ $filename =~ _([0-9]{4})-([0-9]{2})-([0-9]{2})_([0-9]{2})_([0-9]{2}) ]]; then
            local file_date="${BASH_REMATCH[3]}.${BASH_REMATCH[2]} ${BASH_REMATCH[4]}:${BASH_REMATCH[5]}"
            last_backup="$file_date"
            
            # –í—ã—á–∏—Å–ª—è–µ–º "—Å–∫–æ–ª—å–∫–æ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞–∑–∞–¥"
            local file_ts=$(stat -c %Y "$latest_file" 2>/dev/null)
            local now_ts=$(date +%s)
            if [[ -n "$file_ts" ]]; then
                local diff_sec=$((now_ts - file_ts))
                if [[ $diff_sec -lt 60 ]]; then
                    last_backup_ago="—Ç–æ–ª—å–∫–æ —á—Ç–æ"
                elif [[ $diff_sec -lt 3600 ]]; then
                    local mins=$((diff_sec / 60))
                    last_backup_ago="${mins} –º–∏–Ω –Ω–∞–∑–∞–¥"
                elif [[ $diff_sec -lt 86400 ]]; then
                    local hours=$((diff_sec / 3600))
                    last_backup_ago="${hours} —á –Ω–∞–∑–∞–¥"
                else
                    local days=$((diff_sec / 86400))
                    last_backup_ago="${days} –¥–Ω –Ω–∞–∑–∞–¥"
                fi
            fi
        fi
    fi
    
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —á–µ—Ä–µ–∑ –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ (bash –Ω–µ —É–º–µ–µ—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –∑–Ω–∞—á–µ–Ω–∏–π)
    STATS_FULL="$n_full"
    STATS_DB="$n_db"
    STATS_FILES="$n_files"
    STATS_SIZE="$total_size"
    STATS_LAST="$last_backup"
    STATS_LAST_AGO="$last_backup_ago"
}

# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –º–µ—Å—Ç–∞ –Ω–∞ –¥–∏—Å–∫–µ
check_disk_space() {
    local min_space_mb="${1:-1024}"  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é 1GB
    local backup_path="$BACKUP_DIR"
    
    # –ü–æ–ª—É—á–∞–µ–º —Å–≤–æ–±–æ–¥–Ω–æ–µ –º–µ—Å—Ç–æ –≤ MB
    local free_space_kb=$(df -P "$backup_path" 2>/dev/null | tail -1 | awk '{print $4}')
    local free_space_mb=$((free_space_kb / 1024))
    
    if [[ $free_space_mb -lt $min_space_mb ]]; then
        local free_human=$(df -h "$backup_path" 2>/dev/null | tail -1 | awk '{print $4}')
        return 1  # –ú–∞–ª–æ –º–µ—Å—Ç–∞
    fi
    return 0  # –ú–µ—Å—Ç–∞ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ
}

# –ü–æ–ª—É—á–∏—Ç—å —Å–≤–æ–±–æ–¥–Ω–æ–µ –º–µ—Å—Ç–æ –≤ —á–µ–ª–æ–≤–µ–∫–æ—á–∏—Ç–∞–µ–º–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
get_free_space() {
    df -h "$BACKUP_DIR" 2>/dev/null | tail -1 | awk '{print $4}'
}

# --- –°–ò–°–¢–ï–ú–ê –û–ë–ù–û–í–õ–ï–ù–ò–Ø ---

check_for_updates() {
    clear_screen
    echo -e "${CYAN}–ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π...${RESET}"
    
    local REMOTE_CONTENT=""
    local DOWNLOAD_OK=false
    local MAX_RETRIES=3
    local TIMEOUT=15
    
    for attempt in $(seq 1 $MAX_RETRIES); do
        if command -v curl >/dev/null 2>&1; then
            REMOTE_CONTENT=$(curl -sL --connect-timeout $TIMEOUT --max-time 30 "$REMOTE_URL" 2>/dev/null)
        elif command -v wget >/dev/null 2>&1; then
            REMOTE_CONTENT=$(wget -qO- --timeout=$TIMEOUT "$REMOTE_URL" 2>/dev/null)
        else
            print_message "ERROR" "–ù–µ—Ç curl –∏–ª–∏ wget –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π."
            read -erp "Enter..." dummy; return
        fi
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø–æ–ª—É—á–∏–ª–∏ –≤–∞–ª–∏–¥–Ω—ã–π —Å–∫—Ä–∏–ø—Ç
        if [[ -n "$REMOTE_CONTENT" ]] && echo "$REMOTE_CONTENT" | head -1 | grep -q "^#!/bin/bash"; then
            DOWNLOAD_OK=true
            break
        fi
        
        [[ $attempt -lt $MAX_RETRIES ]] && echo -e "${YELLOW}–ü–æ–ø—ã—Ç–∫–∞ $attempt/$MAX_RETRIES –Ω–µ —É–¥–∞–ª–∞—Å—å, –ø–æ–≤—Ç–æ—Ä...${RESET}" && sleep 2
    done
    
    if [[ "$DOWNLOAD_OK" != "true" ]]; then
        print_message "ERROR" "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π."
        echo -e "${GRAY}URL: $REMOTE_URL${RESET}"
        read -erp "Enter..." dummy; return
    fi

    local REMOTE_VERSION=$(echo "$REMOTE_CONTENT" | grep '^VERSION=' | head -1 | cut -d'"' -f2)

    if [[ -z "$REMOTE_VERSION" ]]; then
        print_message "ERROR" "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–µ—Ä—Å–∏–∏."
        echo -e "${GRAY}–§–∞–π–ª –ø–æ–ª—É—á–µ–Ω, –Ω–æ VERSION= –Ω–µ –Ω–∞–π–¥–µ–Ω${RESET}"
        read -erp "Enter..." dummy; return
    fi

    local V_LOCAL=$(echo "$VERSION" | cut -d'-' -f1)
    local V_REMOTE=$(echo "$REMOTE_VERSION" | cut -d'-' -f1)

    echo -e "–¢–µ–∫—É—â–∞—è –≤–µ—Ä—Å–∏—è: ${BOLD}$VERSION${RESET}"
    echo -e "–ê–∫—Ç—É–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è: ${BOLD}$REMOTE_VERSION${RESET}"
    echo ""

    if [[ "$VERSION" == "$REMOTE_VERSION" ]]; then
        print_message "SUCCESS" "–£ –≤–∞—Å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –ø–æ—Å–ª–µ–¥–Ω—è—è –≤–µ—Ä—Å–∏—è."
        read -erp "Enter..." dummy
        return
    fi

    local IS_UPGRADE=false
    if [[ "$(printf '%s\n' "$V_LOCAL" "$V_REMOTE" | sort -V | head -n1)" == "$V_LOCAL" && "$V_LOCAL" != "$V_REMOTE" ]]; then
        IS_UPGRADE=true
    fi

    if [[ "$IS_UPGRADE" == "true" ]]; then
        print_message "WARN" "–î–æ—Å—Ç—É–ø–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ!"
        read -erp "–û–±–Ω–æ–≤–∏—Ç—å —Å–∫—Ä–∏–ø—Ç —Å–µ–π—á–∞—Å? (y/N): " choice
        if [[ "$choice" =~ ^[Yy]$ ]]; then
            perform_update "$REMOTE_CONTENT"
        else
            print_message "INFO" "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ."
            read -erp "Enter..." dummy
        fi
    else
        echo -e "${YELLOW}‚ö†Ô∏è –í–Ω–∏–º–∞–Ω–∏–µ: –í–µ—Ä—Å–∏—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ —Å—Ç–∞—Ä–µ–µ –∏–ª–∏ —Ç–∞–∫–∞—è –∂–µ.${RESET}"
        read -erp "–í—Å–µ —Ä–∞–≤–Ω–æ –∑–∞–≥—Ä—É–∑–∏—Ç—å –≤–µ—Ä—Å–∏—é —Å —Å–µ—Ä–≤–µ—Ä–∞? (y/N): " choice
        if [[ "$choice" =~ ^[Yy]$ ]]; then
            perform_update "$REMOTE_CONTENT"
        else
            print_message "INFO" "–û—Ç–º–µ–Ω–µ–Ω–æ."
            read -erp "Enter..." dummy
        fi
    fi
}

perform_update() {
    local CONTENT="$1"
    local SCRIPT_PATH="$INSTALL_DIR/$SCRIPT_NAME"
    local BACKUP_PATH="$INSTALL_DIR/${SCRIPT_NAME}.backup"
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ
    if ! echo "$CONTENT" | head -n 1 | grep -q "^#!/bin/bash"; then
        print_message "ERROR" "–û—à–∏–±–∫–∞: –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π —Ñ–∞–π–ª –Ω–µ —è–≤–ª—è–µ—Ç—Å—è bash-—Å–∫—Ä–∏–ø—Ç–æ–º."
        read -erp "Enter..." dummy
        return 1
    fi
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä (–∑–∞—â–∏—Ç–∞ –æ—Ç –æ–±—Ä–µ–∑–∞–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤)
    local CONTENT_SIZE=${#CONTENT}
    if [[ $CONTENT_SIZE -lt 10000 ]]; then
        print_message "ERROR" "–û—à–∏–±–∫–∞: –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π —Ñ–∞–π–ª —Å–ª–∏—à–∫–æ–º –º–∞–ª ($CONTENT_SIZE –±–∞–π—Ç)."
        print_message "ERROR" "–í–æ–∑–º–æ–∂–Ω–æ, —Ñ–∞–π–ª –±—ã–ª –ø–æ–≤—Ä–µ–∂–¥—ë–Ω –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ."
        read -erp "Enter..." dummy
        return 1
    fi
    
    # –°–æ–∑–¥–∞—ë–º —Ä–µ–∑–µ—Ä–≤–Ω—É—é –∫–æ–ø–∏—é —Ç–µ–∫—É—â–µ–π –≤–µ—Ä—Å–∏–∏
    if [[ -f "$SCRIPT_PATH" ]]; then
        cp "$SCRIPT_PATH" "$BACKUP_PATH"
        print_message "INFO" "–°–æ–∑–¥–∞–Ω–∞ —Ä–µ–∑–µ—Ä–≤–Ω–∞—è –∫–æ–ø–∏—è: ${SCRIPT_NAME}.backup"
    fi
    
    # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –Ω–æ–≤—É—é –≤–µ—Ä—Å–∏—é
    if echo "$CONTENT" > "$SCRIPT_PATH"; then
        chmod +x "$SCRIPT_PATH"
        print_message "SUCCESS" "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!"
        log_message "SUCCESS" "Script updated to new version"
        echo ""
        echo -e "${CYAN}–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Å–∫—Ä–∏–ø—Ç–∞...${RESET}"
        sleep 1
        exec "$SCRIPT_PATH"
    else
        print_message "ERROR" "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø–∏—Å–∞—Ç—å —Ñ–∞–π–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è!"
        # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–∑ –±—ç–∫–∞–ø–∞
        if [[ -f "$BACKUP_PATH" ]]; then
            mv "$BACKUP_PATH" "$SCRIPT_PATH"
            print_message "WARN" "–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â–∞—è –≤–µ—Ä—Å–∏—è –∏–∑ –±—ç–∫–∞–ø–∞."
        fi
        read -erp "Enter..." dummy
        return 1
    fi
}

# --- –°–ò–°–¢–ï–ú–ê –£–°–¢–ê–ù–û–í–ö–ò ---

install_script() {
    if [[ "$EUID" -ne 0 ]]; then
        echo -e "${RED}–û—à–∏–±–∫–∞: –ó–∞–ø—É—Å—Ç–∏—Ç–µ —Å–∫—Ä–∏–ø—Ç —Å –ø—Ä–∞–≤–∞–º–∏ root (sudo)!${RESET}"
        exit 1
    fi

    local CURRENT_SCRIPT_PATH=$(realpath "$0" 2>/dev/null)
    local INSTALLED_SCRIPT_PATH="$INSTALL_DIR/$SCRIPT_NAME"

    if [[ "$CURRENT_SCRIPT_PATH" == "$INSTALLED_SCRIPT_PATH" ]]; then
        return
    fi

    echo -e "${CYAN}--- –£–°–¢–ê–ù–û–í–ö–ê LAZARUS BACKUP ---${RESET}"
    if [[ ! -d "$INSTALL_DIR" ]]; then
        mkdir -p "$INSTALL_DIR"
        print_message "SUCCESS" "–°–æ–∑–¥–∞–Ω–∞ –ø–∞–ø–∫–∞: $INSTALL_DIR"
    fi

    local DOWNLOAD_SUCCESS=false
    local TEMP_FILE="/tmp/lazarus_install_tmp"

    if [[ -f "$0" && "$0" != "bash" && "$0" != "/dev/fd/"* ]]; then
        cp "$(realpath "$0")" "$INSTALLED_SCRIPT_PATH"
        DOWNLOAD_SUCCESS=true
    else
        print_message "INFO" "–ó–∞–≥—Ä—É–∑–∫–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–π –≤–µ—Ä—Å–∏–∏..."
        if command -v curl >/dev/null 2>&1; then
            curl -sL --connect-timeout 15 --max-time 60 "$REMOTE_URL" -o "$TEMP_FILE"
        elif command -v wget >/dev/null 2>&1; then
            wget -qO "$TEMP_FILE" --timeout=15 "$REMOTE_URL"
        else
            print_message "ERROR" "–î–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –Ω—É–∂–µ–Ω curl –∏–ª–∏ wget!"
            exit 1
        fi

        if [[ -f "$TEMP_FILE" ]]; then
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —ç—Ç–æ bash-—Å–∫—Ä–∏–ø—Ç
            if head -n 1 "$TEMP_FILE" | grep -q "^#!/bin/bash"; then
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä
                local FILE_SIZE=$(stat -c%s "$TEMP_FILE" 2>/dev/null || stat -f%z "$TEMP_FILE" 2>/dev/null || echo "0")
                if [[ $FILE_SIZE -lt 10000 ]]; then
                    print_message "ERROR" "–ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π —Ñ–∞–π–ª —Å–ª–∏—à–∫–æ–º –º–∞–ª ($FILE_SIZE –±–∞–π—Ç)."
                    rm -f "$TEMP_FILE"
                    exit 1
                fi
                mv "$TEMP_FILE" "$INSTALLED_SCRIPT_PATH"
                DOWNLOAD_SUCCESS=true
            else
                print_message "ERROR" "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏! –°–µ—Ä–≤–µ—Ä –≤–µ—Ä–Ω—É–ª –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–∞–π–ª."
                rm -f "$TEMP_FILE"
                exit 1
            fi
        else
            print_message "ERROR" "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å —Ñ–∞–π–ª."
            exit 1
        fi
    fi

    if [[ "$DOWNLOAD_SUCCESS" == "true" ]]; then
        chmod +x "$INSTALLED_SCRIPT_PATH"
        if [[ -L "$SYMLINK_PATH" || -f "$SYMLINK_PATH" ]]; then rm -f "$SYMLINK_PATH"; fi
        ln -s "$INSTALLED_SCRIPT_PATH" "$SYMLINK_PATH"
        
        print_message "SUCCESS" "–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ó–∞–ø—É—Å–∫..."
        echo ""
        exec "$INSTALLED_SCRIPT_PATH"
        exit 0
    fi
}

# --- –Ø–î–†–û –ò–ù–¢–ï–õ–õ–ï–ö–¢–£–ê–õ–¨–ù–û–ì–û –ü–û–ò–°–ö–ê ---

scan_system_for_bot() {
    FOUND_PATH=""; FOUND_BOT=""; FOUND_DB=""
    local running_containers=$(docker ps --format '{{.Names}}|{{.Image}}')
    
    for container in $running_containers; do
        local c_name=$(echo "$container" | cut -d'|' -f1)
        local c_image=$(echo "$container" | cut -d'|' -f2)
        
        if [[ "$c_image" == *"remnawave/backend"* ]]; then continue; fi
        if [[ "$c_image" == *"remnawave/subscription-page"* ]]; then continue; fi
        if [[ "$c_name" == "remnawave" ]]; then continue; fi
        if [[ "$c_name" == "remnawave-db" ]]; then continue; fi 
        if [[ "$c_name" == "remnawave-redis" ]]; then continue; fi

        for key in "${KEYWORDS[@]}"; do
            if [[ "$c_image" == *"$key"* ]]; then
                FOUND_BOT="$c_name"
                local work_dir=$(docker inspect --format '{{ index .Config.Labels "com.docker.compose.project.working_dir" }}' "$c_name")
                if [[ -n "$work_dir" && -d "$work_dir" ]]; then FOUND_PATH="$work_dir"; fi
                break 2
            fi
        done
    done

    if [[ -z "$FOUND_PATH" ]]; then
        local search_dirs=("/opt" "/home" "/root")
        local compose_files=$(find "${search_dirs[@]}" -maxdepth 4 -name "docker-compose.yml" -o -name "compose.yaml" 2>/dev/null)
        for file in $compose_files; do
            if grep -q "remnawave/backend" "$file"; then continue; fi
            if grep -qE "image:.*($(IFS="|"; echo "${KEYWORDS[*]}"))" "$file" || grep -qE "container_name:.*($(IFS="|"; echo "${KEYWORDS[*]}"))" "$file"; then
                FOUND_PATH=$(dirname "$file")
                FOUND_BOT=$(grep "container_name:" "$file" | head -1 | awk '{print $2}' | tr -d '"' | tr -d "'")
                break
            fi
        done
    fi

    if [[ -n "$FOUND_PATH" ]]; then
        if cd "$FOUND_PATH" 2>/dev/null; then
            local db_services=("db" "postgres" "database" "postgresql")
            for svc in "${db_services[@]}"; do
                local db_c=$(docker compose ps -a --format '{{.Name}}' "$svc" 2>/dev/null)
                if [[ -n "$db_c" && "$db_c" != "remnawave-db" ]]; then FOUND_DB="$db_c"; break; fi
            done
            cd - >/dev/null
        fi
    fi
}

# --- –§–£–ù–ö–¶–ò–ò –í–ï–†–°–ò–ò –ò –ü–û–ò–°–ö–ê ---

get_raw_bot_version() {
    if [[ -n "$BOT_CONTAINER_NAME" ]] && docker container inspect -f '{{.State.Running}}' "$BOT_CONTAINER_NAME" &>/dev/null; then
        local full_image=$(docker inspect -f '{{.Config.Image}}' "$BOT_CONTAINER_NAME")
        local ver="${full_image##*:}"
        echo "${ver:-Unknown}"
    else
        echo ""
    fi
}

get_bot_version_display() {
    local ver=$(get_raw_bot_version)
    if [[ -n "$ver" ]]; then echo "$ver"; else echo "N/A"; fi
}

# –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –±–æ—Ç–∞
get_container_status() {
    if [[ -z "$BOT_CONTAINER_NAME" ]]; then
        echo "N/A"
        return
    fi
    
    local status
    status=$(docker inspect -f '{{.State.Status}}' "$BOT_CONTAINER_NAME" 2>/dev/null)
    
    case "$status" in
        "running") echo "Online" ;;
        "exited"|"dead") echo "Offline" ;;
        "paused") echo "Paused" ;;
        "restarting") echo "Restarting" ;;
        *) echo "N/A" ;;
    esac
}

detect_bot_installation() {
    print_message "INFO" "–ó–∞–ø—É—Å–∫ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞..."
    scan_system_for_bot 
    if [[ -n "$FOUND_PATH" ]]; then
        echo ""; print_message "SUCCESS" "–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∞!"
        echo -e "   –ü—É—Ç—å:      ${BOLD}$FOUND_PATH${RESET}"
        [[ -n "$FOUND_BOT" ]] && echo -e "   –ë–æ—Ç:       ${BOLD}$FOUND_BOT${RESET}"
        [[ -n "$FOUND_DB" ]]  && echo -e "   –ë–î:        ${BOLD}$FOUND_DB${RESET}"
        echo ""
        read -erp "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏? (Y/n): " confirm
        if [[ -z "$confirm" || "$confirm" =~ ^[Yy]$ ]]; then
            BOT_PATH="$FOUND_PATH"
            if [[ -n "$FOUND_BOT" ]]; then BOT_CONTAINER_NAME="$FOUND_BOT"; fi
            if [[ -n "$FOUND_DB" ]]; then DB_CONTAINER_NAME="$FOUND_DB"; fi
            save_config; print_message "SUCCESS" "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã."; return 0
        fi
    fi
    print_message "WARN" "–ê–≤—Ç–æ-–ø–æ–∏—Å–∫ –Ω–µ –¥–∞–ª —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞. –í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –≤—Ä—É—á–Ω—É—é –≤ –ù–∞—Å—Ç—Ä–æ–π–∫–∞—Ö."
    return 1
}

# --- –ü–†–û–í–ï–†–ö–ê –ù–ï–°–û–û–¢–í–ï–¢–°–¢–í–ò–ô ---

check_config_mismatch() {
    if [[ -n "$BOT_CONTAINER_NAME" && "$IGNORE_MISMATCH" != "true" ]]; then
        if ! docker inspect "$BOT_CONTAINER_NAME" &>/dev/null; then
            scan_system_for_bot
            if [[ -n "$FOUND_BOT" && "$FOUND_BOT" != "$BOT_CONTAINER_NAME" ]]; then
                echo ""; print_message "WARN" "–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä '$BOT_CONTAINER_NAME' –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–æ –Ω–∞–π–¥–µ–Ω '$FOUND_BOT'."
                echo -e " ${GREEN}–ü—Ä–µ–¥–ª–∞–≥–∞—é –æ–±–Ω–æ–≤–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.${RESET}"
                read -erp "–û–±–Ω–æ–≤–∏—Ç—å? (Y/n): " upd
                if [[ -z "$upd" || "$upd" =~ ^[Yy]$ ]]; then
                    BOT_CONTAINER_NAME="$FOUND_BOT"
                    [[ -n "$FOUND_DB" ]] && DB_CONTAINER_NAME="$FOUND_DB"
                    [[ -n "$FOUND_PATH" ]] && BOT_PATH="$FOUND_PATH"
                    save_config; print_message "SUCCESS" "–û–±–Ω–æ–≤–ª–µ–Ω–æ."; sleep 1
                else
                    IGNORE_MISMATCH="true"; save_config
                fi
            fi
        fi
    fi
}

ensure_bot_path() {
    if [[ -z "$BOT_CONTAINER_NAME" || -z "$DB_CONTAINER_NAME" ]]; then
        echo ""; print_message "WARN" "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ –ø—É—Å—Ç—ã."
        detect_bot_installation; load_or_create_config 
    fi

    local path_valid=false
    if [[ -n "$BOT_PATH" && -d "$BOT_PATH" && ( -f "$BOT_PATH/docker-compose.yml" || -f "$BOT_PATH/compose.yaml" ) ]]; then path_valid=true; fi
    local container_valid=false
    if [[ -n "$BOT_CONTAINER_NAME" ]] && docker inspect "$BOT_CONTAINER_NAME" &>/dev/null; then container_valid=true; fi
    local db_valid=false
    if [[ -n "$DB_CONTAINER_NAME" ]] && docker inspect "$DB_CONTAINER_NAME" &>/dev/null; then db_valid=true; fi

    if [[ "$path_valid" == "false" || "$container_valid" == "false" || "$db_valid" == "false" ]]; then
        if [[ "$path_valid" == "false" ]]; then
            detect_bot_installation; load_or_create_config
            if [[ -n "$BOT_PATH" ]]; then path_valid=true; fi
            if [[ -n "$BOT_CONTAINER_NAME" ]]; then container_valid=true; fi
            if [[ -n "$DB_CONTAINER_NAME" ]]; then db_valid=true; fi
        fi

        if [[ -z "$BOT_PATH" || ! -d "$BOT_PATH" ]]; then
            echo ""; print_message "ACTION" "–£–∫–∞–∂–∏—Ç–µ –ø—É—Ç—å –∫ –ø–∞–ø–∫–µ –±–æ—Ç–∞ –≤—Ä—É—á–Ω—É—é."
            read -erp "–ü—É—Ç—å (Enter –¥–ª—è '$DEFAULT_BOT_PATH'): " input_path
            BOT_PATH="${input_path:-$DEFAULT_BOT_PATH}"
            if [[ ! -d "$BOT_PATH" ]]; then print_message "ERROR" "–ü–∞–ø–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!"; return 1; fi
            save_config
        fi

        if [[ -z "$BOT_CONTAINER_NAME" ]] || ! docker inspect "$BOT_CONTAINER_NAME" &>/dev/null; then
            echo ""; print_message "WARN" "–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –±–æ—Ç–∞ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω."
            print_message "ACTION" "–í–≤–µ–¥–∏—Ç–µ –∏–º—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –±–æ—Ç–∞ (–∫–∞–∫ –≤ 'docker ps')."
            read -erp "–ò–º—è: " input_name
            if [[ -n "$input_name" ]]; then BOT_CONTAINER_NAME="$input_name"; else BOT_CONTAINER_NAME="shopbot"; fi
            save_config
        fi

        if [[ -z "$DB_CONTAINER_NAME" ]] || ! docker inspect "$DB_CONTAINER_NAME" &>/dev/null; then
            echo ""; print_message "WARN" "–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –ë–∞–∑—ã –î–∞–Ω–Ω—ã—Ö –Ω–µ –Ω–∞–π–¥–µ–Ω."
            print_message "ACTION" "–í–≤–µ–¥–∏—Ç–µ –∏–º—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –ë–î (–∏–ª–∏ Enter –¥–ª—è '$DEFAULT_DB_NAME')."
            read -erp "–ò–º—è –ë–î: " input_db
            if [[ -n "$input_db" ]]; then DB_CONTAINER_NAME="$input_db"; else DB_CONTAINER_NAME="$DEFAULT_DB_NAME"; fi
            save_config
        fi
    fi
    return 0
}

save_config() {
    mkdir -p "$INSTALL_DIR"
    cat > "$CONFIG_FILE" <<EOF
BOT_TOKEN="$BOT_TOKEN"
CHAT_ID="$CHAT_ID"
TG_MESSAGE_THREAD_ID="$TG_MESSAGE_THREAD_ID"
BOT_PATH="$BOT_PATH"
DB_USER="$DB_USER"
SCHEDULE_FULL="$SCHEDULE_FULL"
SCHEDULE_DB="$SCHEDULE_DB"
SCHEDULE_FILES="$SCHEDULE_FILES"
MAX_BACKUPS_COUNT="$MAX_BACKUPS_COUNT"
BOT_CONTAINER_NAME="$BOT_CONTAINER_NAME"
DB_CONTAINER_NAME="$DB_CONTAINER_NAME"
IGNORE_MISMATCH="$IGNORE_MISMATCH"
EXCLUDE_DIRS="$EXCLUDE_DIRS"
MAX_FILE_SIZE_MB="$MAX_FILE_SIZE_MB"
REMOTE_STORAGE_TYPE="$REMOTE_STORAGE_TYPE"
REMOTE_STORAGE_URL="$REMOTE_STORAGE_URL"
REMOTE_STORAGE_USER="$REMOTE_STORAGE_USER"
REMOTE_STORAGE_PASS="$REMOTE_STORAGE_PASS"
BACKUP_PASSWORD="$BACKUP_PASSWORD"
SEND_TO_TELEGRAM="$SEND_TO_TELEGRAM"
TG_SEND_FILE="$TG_SEND_FILE"
SEND_TO_REMOTE="$SEND_TO_REMOTE"
DELETE_MODE="$DELETE_MODE"
RETENTION_DAYS="$RETENTION_DAYS"
EOF
    chmod 600 "$CONFIG_FILE"
}

load_or_create_config() {
    if [[ -f "$CONFIG_FILE" ]]; then source "$CONFIG_FILE"; fi
    if [[ -z "$MAX_BACKUPS_COUNT" ]]; then MAX_BACKUPS_COUNT=100; fi
    if [[ -z "$IGNORE_MISMATCH" ]]; then IGNORE_MISMATCH="false"; fi
    if [[ -z "$MAX_FILE_SIZE_MB" ]]; then MAX_FILE_SIZE_MB="1"; fi
    if [[ -z "$REMOTE_STORAGE_TYPE" ]]; then REMOTE_STORAGE_TYPE="off"; fi
    if [[ -z "$SEND_TO_TELEGRAM" ]]; then SEND_TO_TELEGRAM="true"; fi
    if [[ -z "$TG_SEND_FILE" ]]; then TG_SEND_FILE="true"; fi
    if [[ -z "$SEND_TO_REMOTE" ]]; then SEND_TO_REMOTE="true"; fi
    if [[ -z "$DELETE_MODE" ]]; then DELETE_MODE="time"; fi
    if [[ -z "$RETENTION_DAYS" ]]; then RETENTION_DAYS="7"; fi
    mkdir -p "$BACKUP_DIR"

    local updated=false
    if [[ -z "$BOT_TOKEN" || -z "$CHAT_ID" ]]; then
        echo ""; print_message "WARN" "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ Telegram –Ω–µ –Ω–∞–π–¥–µ–Ω—ã."
        [[ -z "$BOT_TOKEN" ]] && read -erp " –í–≤–µ–¥–∏—Ç–µ Bot Token: " BOT_TOKEN
        [[ -z "$CHAT_ID" ]] && read -erp " –í–≤–µ–¥–∏—Ç–µ Chat ID: " CHAT_ID
        [[ -z "$TG_MESSAGE_THREAD_ID" ]] && read -erp " –í–≤–µ–¥–∏—Ç–µ ID —Ç–æ–ø–∏–∫–∞ (–∏–ª–∏ Enter): " TG_MESSAGE_THREAD_ID
        updated=true
    fi
    
    if [[ -z "$BOT_PATH" || -z "$BOT_CONTAINER_NAME" || -z "$DB_CONTAINER_NAME" ]]; then 
        detect_bot_installation
    fi
    
    if $updated; then save_config; fi
}

send_telegram_document() {
    local file_path="$1"; local caption="$2"
    [[ -z "$BOT_TOKEN" || -z "$CHAT_ID" ]] && return 1
    
    # –ï—Å–ª–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—Ç–∫–ª—é—á–µ–Ω—ã
    if [[ "$SEND_TO_TELEGRAM" != "true" ]]; then
        print_message "INFO" "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è Telegram –æ—Ç–∫–ª—é—á–µ–Ω—ã."
        return 0
    fi
    
    # –ï—Å–ª–∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–∞–π–ª–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞ ‚Äî –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
    if [[ "$TG_SEND_FILE" != "true" ]]; then
        print_message "INFO" "–û—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–∞–π–ª–∞ –≤ TG –æ—Ç–∫–ª—é—á–µ–Ω–∞, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ..."
        local filename=$(basename "$file_path")
        local notify_text="${caption}

üìÅ –§–∞–π–ª: \`${filename}\`
üí° _–û—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–∞–π–ª–∞ –≤ Telegram –æ—Ç–∫–ª—é—á–µ–Ω–∞_"
        send_telegram_text "$notify_text"
        return 0
    fi
    
    print_message "INFO" "–û—Ç–ø—Ä–∞–≤–∫–∞ –≤ Telegram..."
    
    local form_params=(-F chat_id="$CHAT_ID" -F document=@"$file_path" -F parse_mode="MarkdownV2" -F caption="$(escape_markdown_v2 "$caption")")
    [[ -n "$TG_MESSAGE_THREAD_ID" ]] && form_params+=(-F message_thread_id="$TG_MESSAGE_THREAD_ID")
    
    local http_code=$(curl -s -o /dev/null -w "%{http_code}" -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendDocument" "${form_params[@]}")
    
    if [[ "$http_code" == "200" ]]; then
        print_message "SUCCESS" "–£—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ Telegram."
    else
        local file_size=$(stat -c%s "$file_path" 2>/dev/null || echo 0)
        
        if [[ $file_size -ge 52428800 ]]; then
            print_message "ERROR" "–§–∞–π–ª >50MB. Telegram API –æ—Ç–∫–ª–æ–Ω–∏–ª –æ—Ç–ø—Ä–∞–≤–∫—É."
            local error_msg="‚ö†Ô∏è *–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –±—ç–∫–∞–ø–∞*

–§–∞–π–ª –∑–∞–Ω–∏–º–∞–µ—Ç –±–æ–ª—å—à–µ 50 –ú–ë\. Telegram Bot API –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç –∑–∞–≥—Ä—É–∂–∞—Ç—å —Ç–∞–∫–∏–µ —Ñ–∞–π–ª—ã –Ω–∞–ø—Ä—è–º—É—é\.

üìÇ *–ë—ç–∫–∞–ø —Å–æ—Ö—Ä–∞–Ω–µ–Ω –ª–æ–∫–∞–ª—å–Ω–æ:*
\`$(basename "$file_path")\`"
            
            local thread_param=""
            [[ -n "$TG_MESSAGE_THREAD_ID" ]] && thread_param="-d message_thread_id=$TG_MESSAGE_THREAD_ID"

            curl -s -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" \
                -d chat_id="$CHAT_ID" \
                -d text="$error_msg" \
                -d parse_mode="MarkdownV2" \
                $thread_param >/dev/null
        else
            print_message "ERROR" "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ Telegram (HTTP –∫–æ–¥: $http_code)."
        fi
    fi
}

send_telegram_text() {
    # send simple text message to configured chat
    local text="$1"
    [[ -z "$BOT_TOKEN" || -z "$CHAT_ID" ]] && return 1
    local thread_param=""
    [[ -n "$TG_MESSAGE_THREAD_ID" ]] && thread_param="-d message_thread_id=$TG_MESSAGE_THREAD_ID"
    curl -s -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" \
        -d chat_id="$CHAT_ID" \
        -d text="$text" \
        -d parse_mode="MarkdownV2" $thread_param >/dev/null 2>&1
}

test_telegram_connection() {
    print_message "INFO" "–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤—è–∑–∏ —Å Telegram API..."
    local res=$(curl -s "https://api.telegram.org/bot$BOT_TOKEN/getMe")
    if [[ "$res" == *'"ok":true'* ]]; then
        local bot_user=$(echo "$res" | grep -o '"username":"[^"]*"' | cut -d'"' -f4)
        print_message "SUCCESS" "–£—Å–ø–µ—Ö! –ë–æ—Ç: @$bot_user"
    else
        print_message "ERROR" "–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ç–æ–∫–µ–Ω."
    fi
    read -erp "Enter..." dummy
}

validate_remote_connection() {
    local type="$1"; local url="$2"; local user="$3"; local pass="$4"
    print_message "INFO" "–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è ($type)..."
    
    local base_url="${url%/}"
    
    if [[ "$type" == "ftp" ]]; then
        # FTP: –ø—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏—Å—Ç–∏–Ω–≥ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
        local curl_cmd=(curl -s -m 15 --ftp-pasv --list-only)
        [[ -n "$user" ]] && curl_cmd+=(--user "$user:$pass")
        
        # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ FTPS (implicit –∏ explicit)
        if [[ "$base_url" == ftps://* ]]; then
            curl_cmd+=(--ssl-reqd --insecure)
        elif [[ "$base_url" == ftp://* ]]; then
            # –ü–æ–ø—Ä–æ–±—É–µ–º explicit TLS –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω
            curl_cmd+=(--ssl --insecure)
        fi
        
        if "${curl_cmd[@]}" "$base_url/" >/dev/null 2>&1; then 
            return 0
        else 
            # –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ –±–µ–∑ TLS –¥–ª—è –æ–±—ã—á–Ω–æ–≥–æ FTP
            if [[ "$base_url" == ftp://* ]]; then
                curl_cmd=(curl -s -m 15 --ftp-pasv --list-only)
                [[ -n "$user" ]] && curl_cmd+=(--user "$user:$pass")
                if "${curl_cmd[@]}" "$base_url/" >/dev/null 2>&1; then
                    return 0
                fi
            fi
            return 1
        fi
        
    elif [[ "$type" == "webdav" ]]; then
        # WebDAV: PROPFIND —Å Depth: 0
        local curl_cmd=(curl -s -m 15 -L)
        [[ -n "$user" ]] && curl_cmd+=(--user "$user:$pass")
        
        # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Å–∞–º–æ–ø–æ–¥–ø–∏—Å–∞–Ω–Ω—ã—Ö —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–≤
        [[ "$base_url" == https://* ]] && curl_cmd+=(--insecure)
        
        local http_code
        http_code=$("${curl_cmd[@]}" -o /dev/null -w "%{http_code}" -X PROPFIND -H "Depth: 0" "$base_url/" 2>/dev/null)
        
        # 207 Multi-Status ‚Äî —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —É—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç WebDAV
        # 200 OK ‚Äî –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Å–µ—Ä–≤–µ—Ä—ã –æ—Ç–≤–µ—á–∞—é—Ç —Ç–∞–∫
        # 301/302 ‚Äî —Ä–µ–¥–∏—Ä–µ–∫—Ç (curl -L –æ–±—Ä–∞–±–æ—Ç–∞–µ—Ç)
        if [[ "$http_code" =~ ^(200|207)$ ]]; then 
            return 0
        else 
            # Fallback: –ø–æ–ø—Ä–æ–±—É–µ–º –ø—Ä–æ—Å—Ç–æ–π GET
            http_code=$("${curl_cmd[@]}" -o /dev/null -w "%{http_code}" "$base_url/" 2>/dev/null)
            if [[ "$http_code" =~ ^(200|207|401)$ ]]; then
                # 401 –æ–∑–Ω–∞—á–∞–µ—Ç —á—Ç–æ —Å–µ—Ä–≤–µ—Ä –æ—Ç–≤–µ—á–∞–µ—Ç, –Ω–æ –Ω—É–∂–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
                return 0
            fi
            return 1
        fi
        
    elif [[ "$type" == "rclone" ]]; then
        if ! command -v rclone >/dev/null 2>&1; then
            print_message "ERROR" "Rclone –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!"
            return 1
        fi
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å remote
        local remote_name="${url%%:*}"
        if rclone listremotes 2>/dev/null | grep -q "^${remote_name}:$"; then
            # Remote —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –ø—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å
            if rclone lsd "$url" >/dev/null 2>&1; then 
                return 0
            fi
        fi
        return 1
    fi
    
    return 1
}

upload_to_remote() {
    if [[ "$SEND_TO_REMOTE" != "true" ]]; then return 0; fi
    local file_path="$1"
    local filename=$(basename "$file_path")
    local file_size=$(stat -c%s "$file_path" 2>/dev/null || echo "0")
    REMOTE_UPLOAD_STATUS_TEXT="" 

    if [[ "$REMOTE_STORAGE_TYPE" == "off" || -z "$REMOTE_STORAGE_URL" ]]; then return 0; fi
    
    if [[ ! -f "$file_path" ]]; then
        print_message "ERROR" "–§–∞–π–ª –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω: $file_path" >&2
        log_message "ERROR" "Upload failed: file not found $file_path"
        return 1
    fi

    print_message "INFO" "–ó–∞–≥—Ä—É–∑–∫–∞ –Ω–∞ $REMOTE_STORAGE_TYPE ($(numfmt --to=iec $file_size 2>/dev/null || echo "${file_size}B"))..." >&2

    # === RCLONE ===
    if [[ "$REMOTE_STORAGE_TYPE" == "rclone" ]]; then
        if ! command -v rclone >/dev/null 2>&1; then
            print_message "ERROR" "Rclone –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!"
            REMOTE_UPLOAD_STATUS_TEXT=$'\n‚òÅÔ∏è Rclone: –ù–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'
            return 1
        fi
        local dest="${REMOTE_STORAGE_URL%/}"
        local rclone_opts=(--progress --retries 3 --low-level-retries 10)
        [[ "$IS_INTERACTIVE" != "true" ]] && rclone_opts=(--quiet --retries 3 --low-level-retries 10)
        
        if rclone copy "$file_path" "$dest" "${rclone_opts[@]}" 2>&1; then
            print_message "SUCCESS" "–§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω (rclone)." >&2
            REMOTE_UPLOAD_STATUS_TEXT=$'\n‚òÅÔ∏è Rclone: OK'
            log_message "SUCCESS" "Uploaded $filename to rclone:$dest"
            return 0
        else
            print_message "ERROR" "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ rclone." >&2
            REMOTE_UPLOAD_STATUS_TEXT=$'\n‚òÅÔ∏è Rclone: –û—à–∏–±–∫–∞'
            log_message "ERROR" "Failed upload $filename to rclone:$dest"
            return 1
        fi
    fi

    # === FTP / WEBDAV ===
    local upload_url="${REMOTE_STORAGE_URL%/}/$filename"
    local max_retries=3
    local retry_delay=5
    local attempt=1
    local http_code=""
    local upload_success=false
    
    # –†–∞—Å—á—ë—Ç —Ç–∞–π–º–∞—É—Ç–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–∞–∑–º–µ—Ä–∞ —Ñ–∞–π–ª–∞ (–º–∏–Ω–∏–º—É–º 120 —Å–µ–∫, +60 —Å–µ–∫ –Ω–∞ –∫–∞–∂–¥—ã–µ 50MB)
    local timeout=$((120 + (file_size / 50000000) * 60))
    [[ $timeout -gt 1800 ]] && timeout=1800  # –ú–∞–∫—Å–∏–º—É–º 30 –º–∏–Ω—É—Ç
    
    while [[ $attempt -le $max_retries ]]; do
        [[ $attempt -gt 1 ]] && print_message "INFO" "–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ $attempt/$max_retries..." >&2
        
        # –ë–∞–∑–æ–≤—ã–µ –æ–ø—Ü–∏–∏ curl
        local curl_opts=(-o /dev/null -w "%{http_code}" -m "$timeout" -T "$file_path")
        
        # –ü—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä –∏–ª–∏ —Ç–∏—Ö–∏–π —Ä–µ–∂–∏–º
        if [[ "$IS_INTERACTIVE" == "true" ]]; then
            curl_opts+=(-#)
        else
            curl_opts+=(-s)
        fi
        
        # –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
        [[ -n "$REMOTE_STORAGE_USER" ]] && curl_opts+=(--user "$REMOTE_STORAGE_USER:$REMOTE_STORAGE_PASS")
        
        if [[ "$REMOTE_STORAGE_TYPE" == "ftp" ]]; then
            # FTP —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –æ–ø—Ü–∏–∏
            curl_opts+=(--ftp-pasv)              # Passive mode (—Ä–∞–±–æ—Ç–∞–µ—Ç –∑–∞ NAT)
            curl_opts+=(--ftp-create-dirs)       # –°–æ–∑–¥–∞—Ç—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            
            # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ FTPS
            if [[ "$upload_url" == ftps://* ]]; then
                curl_opts+=(--ssl-reqd --insecure)
            elif [[ "$upload_url" == ftp://* ]]; then
                curl_opts+=(--ssl --insecure)    # –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å TLS –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω
            fi
            
            curl_opts+=("$upload_url")
            http_code=$(curl "${curl_opts[@]}" 2>/dev/null) || http_code="000"
            
            # FTP –∫–æ–¥—ã —É—Å–ø–µ—Ö–∞: 226 (Transfer complete), 250 (Requested file action okay)
            if [[ "$http_code" =~ ^(226|250|200)$ ]]; then
                upload_success=true
                break
            fi
            
        elif [[ "$REMOTE_STORAGE_TYPE" == "webdav" ]]; then
            # WebDAV —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –æ–ø—Ü–∏–∏
            curl_opts+=(-L)                      # –°–ª–µ–¥–æ–≤–∞—Ç—å —Ä–µ–¥–∏—Ä–µ–∫—Ç–∞–º
            curl_opts+=(--retry 2)               # –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π retry curl
            curl_opts+=(--retry-delay 3)
            
            # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ HTTPS —Å —Å–∞–º–æ–ø–æ–¥–ø–∏—Å–∞–Ω–Ω—ã–º–∏ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞–º–∏
            [[ "$upload_url" == https://* ]] && curl_opts+=(--insecure)
            
            curl_opts+=("$upload_url")
            http_code=$(curl "${curl_opts[@]}" 2>/dev/null) || http_code="000"
            
            # WebDAV –∫–æ–¥—ã —É—Å–ø–µ—Ö–∞: 200 OK, 201 Created, 204 No Content
            if [[ "$http_code" =~ ^(200|201|204)$ ]]; then
                upload_success=true
                break
            fi
        fi
        
        # –õ–æ–≥–∏—Ä—É–µ–º –Ω–µ—É–¥–∞—á–Ω—É—é –ø–æ–ø—ã—Ç–∫—É
        log_message "WARN" "Upload attempt $attempt failed: HTTP $http_code for $upload_url"
        
        ((attempt++))
        [[ $attempt -le $max_retries ]] && sleep $retry_delay
    done
    
    if [[ "$upload_success" == true ]]; then
        print_message "SUCCESS" "–§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ." >&2
        if [[ "$REMOTE_STORAGE_TYPE" == "ftp" ]]; then 
            REMOTE_UPLOAD_STATUS_TEXT=$'\n‚òÅÔ∏è FTP: OK'
        else 
            REMOTE_UPLOAD_STATUS_TEXT=$'\n‚òÅÔ∏è WebDAV: OK'
        fi
        log_message "SUCCESS" "Uploaded $filename to $REMOTE_STORAGE_TYPE ($upload_url) HTTP=$http_code"
        return 0
    else
        print_message "ERROR" "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–æ—Å–ª–µ $max_retries –ø–æ–ø—ã—Ç–æ–∫ (–ö–æ–¥: $http_code)" >&2
        if [[ "$REMOTE_STORAGE_TYPE" == "ftp" ]]; then 
            REMOTE_UPLOAD_STATUS_TEXT=$'\n‚òÅÔ∏è FTP: –û—à–∏–±–∫–∞'
        else 
            REMOTE_UPLOAD_STATUS_TEXT=$'\n‚òÅÔ∏è WebDAV: –û—à–∏–±–∫–∞'
        fi
        log_message "ERROR" "Failed upload $filename to $REMOTE_STORAGE_TYPE after $max_retries attempts. Last HTTP=$http_code"
        return 1
    fi
}

configure_remote_storage() {
    while true; do
        clear_screen
        echo -e "${GREEN}${BOLD}–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–¥–∞–ª—ë–Ω–Ω–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞${RESET}"
        echo ""
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å
        if [[ "$REMOTE_STORAGE_TYPE" != "off" && -n "$REMOTE_STORAGE_URL" ]]; then
            echo -e "–¢–µ–∫—É—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:"
            echo -e "  –¢–∏–ø: ${YELLOW}${REMOTE_STORAGE_TYPE^^}${RESET}"
            echo -e "  URL: ${GRAY}${REMOTE_STORAGE_URL}${RESET}"
            [[ -n "$REMOTE_STORAGE_USER" ]] && echo -e "  –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: ${GRAY}${REMOTE_STORAGE_USER}${RESET}"
            echo ""
        fi
        
        echo " 1. FTP / FTPS"
        echo " 2. WebDAV (–Ø–Ω–¥–µ–∫—Å.–î–∏—Å–∫, Nextcloud, –∏ –¥—Ä.)"
        echo " 3. Rclone (Google Drive, S3, Dropbox, –∏ –¥—Ä.)"
        echo ""
        echo -e " ${RED}0. –û—Ç–∫–ª—é—á–∏—Ç—å${RESET}"
        echo ""
        read -erp "–í—ã–±–æ—Ä (Enter - –ù–∞–∑–∞–¥): " r_type
        [[ -z "$r_type" ]] && return
        
        local new_type="off"
        local input_url="" input_user="" input_pass=""
        
        case $r_type in
            1) new_type="ftp" ;;
            2) new_type="webdav" ;;
            3) new_type="rclone" ;;
            0) 
                REMOTE_STORAGE_TYPE="off"
                REMOTE_STORAGE_URL=""
                REMOTE_STORAGE_USER=""
                REMOTE_STORAGE_PASS=""
                save_config
                print_message "SUCCESS" "–£–¥–∞–ª—ë–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ."
                sleep 1
                return 
                ;;
            *) continue ;;
        esac

        echo ""
        
        if [[ "$new_type" == "ftp" ]]; then
            echo -e "${CYAN}–ù–∞—Å—Ç—Ä–æ–π–∫–∞ FTP/FTPS${RESET}"
            echo ""
            echo "–ü—Ä–∏–º–µ—Ä—ã URL:"
            echo -e "  ${GRAY}ftp://backup.example.com/backups${RESET}"
            echo -e "  ${GRAY}ftps://secure.example.com:990/folder${RESET}"
            echo ""
            read -erp "URL —Å–µ—Ä–≤–µ—Ä–∞ (Enter - –Ω–∞–∑–∞–¥): " input_url
            [[ -z "$input_url" ]] && continue
            read -erp "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: " input_user
            read -s -erp "–ü–∞—Ä–æ–ª—å: " input_pass
            echo ""
            
        elif [[ "$new_type" == "webdav" ]]; then
            echo -e "${CYAN}–ù–∞—Å—Ç—Ä–æ–π–∫–∞ WebDAV${RESET}"
            echo ""
            echo "–ü—Ä–∏–º–µ—Ä—ã URL:"
            echo -e "  ${GRAY}https://webdav.yandex.ru/backups${RESET}       (–Ø–Ω–¥–µ–∫—Å.–î–∏—Å–∫)"
            echo -e "  ${GRAY}https://cloud.example.com/remote.php/dav/files/user/backups${RESET} (Nextcloud)"
            echo ""
            read -erp "URL —Å–µ—Ä–≤–µ—Ä–∞ (Enter - –Ω–∞–∑–∞–¥): " input_url
            [[ -z "$input_url" ]] && continue
            read -erp "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: " input_user
            read -s -erp "–ü–∞—Ä–æ–ª—å (–∏–ª–∏ —Ç–æ–∫–µ–Ω –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è): " input_pass
            echo ""
            
        elif [[ "$new_type" == "rclone" ]]; then
            echo -e "${CYAN}–ù–∞—Å—Ç—Ä–æ–π–∫–∞ Rclone${RESET}"
            echo ""
            if ! command -v rclone >/dev/null 2>&1; then
                print_message "ERROR" "Rclone –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!"
                echo -e "–£—Å—Ç–∞–Ω–æ–≤–∫–∞: ${GRAY}curl https://rclone.org/install.sh | sudo bash${RESET}"
                read -erp "Enter..." dummy
                continue
            fi
            echo "–î–æ—Å—Ç—É–ø–Ω—ã–µ remotes:"
            rclone listremotes 2>/dev/null | sed 's/^/  /'
            echo ""
            echo "–ü—Ä–∏–º–µ—Ä—ã –ø—É—Ç–µ–π:"
            echo -e "  ${GRAY}gdrive:backups${RESET}        (Google Drive)"
            echo -e "  ${GRAY}s3:bucket/backups${RESET}     (Amazon S3)"
            echo -e "  ${GRAY}dropbox:backups${RESET}       (Dropbox)"
            echo ""
            read -erp "Rclone –ø—É—Ç—å (Enter - –Ω–∞–∑–∞–¥): " input_url
            [[ -z "$input_url" ]] && continue
            input_user=""
            input_pass=""
        fi

        echo ""
        print_message "INFO" "–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è..."
        
        if validate_remote_connection "$new_type" "$input_url" "$input_user" "$input_pass"; then
            print_message "SUCCESS" "–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ!"
            REMOTE_STORAGE_TYPE="$new_type"
            REMOTE_STORAGE_URL="$input_url"
            REMOTE_STORAGE_USER="$input_user"
            REMOTE_STORAGE_PASS="$input_pass"
            save_config
            print_message "SUCCESS" "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã."
            sleep 1.5
            return
        else
            print_message "ERROR" "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É!"
            echo ""
            read -erp "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ –æ—à–∏–±–∫—É? (y/N): " force_save
            if [[ "$force_save" =~ ^[Yy]$ ]]; then
                REMOTE_STORAGE_TYPE="$new_type"
                REMOTE_STORAGE_URL="$input_url"
                REMOTE_STORAGE_USER="$input_user"
                REMOTE_STORAGE_PASS="$input_pass"
                save_config
                print_message "WARN" "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã (—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ)."
                sleep 1.5
                return
            else
                print_message "INFO" "–û—Ç–º–µ–Ω–µ–Ω–æ. –í–æ–∑–≤—Ä–∞—Ç –∫ –≤—ã–±–æ—Ä—É —Ç–∏–ø–∞..."
                sleep 1
            fi
        fi
    done
}

# --- –†–û–¢–ê–¶–ò–Ø (–£–î–ê–õ–ï–ù–ò–ï –õ–ò–®–ù–ò–•) ---

rotate_backups_by_count() {
    local PREFIX="$1"
    local LABEL="$2"
    local PERFORM_DELETE="$3" 
    
    # –°–¢–†–û–ì–ò–ô –ü–û–ò–°–ö (–¢–æ–ª—å–∫–æ –∞—Ä—Ö–∏–≤—ã), —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ (—Å—Ç–∞—Ä—ã–µ –≤ –Ω–∞—á–∞–ª–µ)
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º ls -1tr –¥–ª—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –∏ while read –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∏–º–µ–Ω —Å –ø—Ä–æ–±–µ–ª–∞–º–∏
    local files=()
    while IFS= read -r f; do
        files+=("$f")
    done < <(ls -1tr "$BACKUP_DIR"/${PREFIX}_*.tar.gz "$BACKUP_DIR"/${PREFIX}_*.tar.gz.enc 2>/dev/null)
    
    local count=${#files[@]}
    local diff=$((count - MAX_BACKUPS_COUNT))
    
    if [[ $diff -gt 0 ]]; then
        if [[ "$PERFORM_DELETE" == "true" ]]; then
            if [[ "$DRY_RUN" == "true" ]]; then
                echo -e "${YELLOW}[DRY-RUN] –ö–∞—Ç–µ–≥–æ—Ä–∏—è '$LABEL': –±—ã–ª–æ –±—ã —É–¥–∞–ª–µ–Ω–æ $diff —Å—Ç–∞—Ä—ã—Ö —Ñ–∞–π–ª–æ–≤ (–ª–∏–º–∏—Ç $MAX_BACKUPS_COUNT).${RESET}"
                log_message "INFO" "[DRY_RUN] Would delete $diff files (count-based rotation, prefix=$PREFIX, limit=$MAX_BACKUPS_COUNT)"
                echo "$diff"
                return 0
            fi
            echo -e "${YELLOW}–û—á–∏—Å—Ç–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ '$LABEL' (—É–¥–∞–ª–µ–Ω–∏–µ $diff —Å—Ç–∞—Ä—ã—Ö —Ñ–∞–π–ª–æ–≤):${RESET}"
            for (( i=0; i<diff; i++ )); do
                local file_to_del="${files[$i]}"
                if [[ -f "$file_to_del" ]]; then
                    rm -f "$file_to_del"
                    rm -f "$file_to_del.version"
                    echo "  üóë –£–¥–∞–ª–µ–Ω: $(basename "$file_to_del")"
                    log_message "INFO" "Deleted $file_to_del (count-based rotation, prefix=$PREFIX)"
                fi
            done
            echo "$diff"
            return 0
        else
            echo -e " $LABEL: –ù–∞–π–¥–µ–Ω–æ $count (–õ–∏–º–∏—Ç $MAX_BACKUPS_COUNT) -> ${RED}–ö–∞–Ω–¥–∏–¥–∞—Ç—ã –Ω–∞ —É–¥–∞–ª–µ–Ω–∏–µ: $diff —à—Ç.${RESET}"
            echo "$diff"
            return 0
        fi
        return 0
    else
        if [[ "$PERFORM_DELETE" != "true" ]]; then
            echo -e " $LABEL: –ù–∞–π–¥–µ–Ω–æ $count (–õ–∏–º–∏—Ç $MAX_BACKUPS_COUNT) -> ${GREEN}OK${RESET}"
        fi
        echo "0"
        return 0
    fi
}

rotate_backups_by_age() {
    local PREFIX="$1"
    local LABEL="$2"
    local DAYS="$3"
    local PERFORM_DELETE="$4"

    # –ò—â–µ–º —Ç–æ–ª—å–∫–æ –∞—Ä—Ö–∏–≤—ã (–≤–∫–ª—é—á–∞—è .enc)
    local pattern1="$BACKUP_DIR/${PREFIX}_*.tar.gz"
    local pattern2="$BACKUP_DIR/${PREFIX}_*.tar.gz.enc"

    # –ù–∞–π–¥—ë–º —Ñ–∞–π–ª—ã —Å—Ç–∞—Ä—à–µ DAYS –¥–Ω–µ–π
    local files=()
    # find -mtime +N –æ–∑–Ω–∞—á–∞–µ—Ç "—Å—Ç—Ä–æ–≥–æ –±–æ–ª—å—à–µ N –¥–Ω–µ–π". –ß—Ç–æ–±—ã RETENTION_DAYS=N –æ–∑–Ω–∞—á–∞–ª
    # "—É–¥–∞–ª—è—Ç—å —Ñ–∞–π–ª—ã —Å—Ç–∞—Ä—à–µ N –¥–Ω–µ–π", –∏—Å–ø–æ–ª—å–∑—É–µ–º -mtime +$((N-1)). –î–ª—è N==0 ‚Äî –±—É–¥–µ–º
    # —É–¥–∞–ª—è—Ç—å –≤—Å–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–µ —Ñ–∞–π–ª—ã.
    # –°–æ–±–∏—Ä–∞–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç—ã find –±–µ–∑ eval
    local find_args=("$BACKUP_DIR" -maxdepth 1 \( -name "${PREFIX}_*.tar.gz" -o -name "${PREFIX}_*.tar.gz.enc" \) -type f)
    if [[ "$DAYS" -le 0 ]]; then
        # –ï—Å–ª–∏ 0 –∏–ª–∏ –º–µ–Ω—å—à–µ - –Ω–µ —É–¥–∞–ª—è–µ–º –Ω–∏—á–µ–≥–æ (–∑–∞—â–∏—Ç–∞ –æ—Ç –ø–æ–ª–Ω–æ–π –æ—á–∏—Å—Ç–∫–∏)
        return 0
    else
        local nd=$((DAYS - 1))
        find_args+=( -mtime +"$nd" )
    fi
    find_args+=( -print0 )
    while IFS= read -r -d $'\0' f; do files+=("$f"); done < <(find "${find_args[@]}" 2>/dev/null)

    local count=${#files[@]}

    if [[ $count -gt 0 ]]; then
        if [[ "$PERFORM_DELETE" == "true" ]]; then
            if [[ "$DRY_RUN" == "true" ]]; then
                echo -e "${YELLOW}[DRY-RUN] –ö–∞—Ç–µ–≥–æ—Ä–∏—è '$LABEL': –±—ã–ª–æ –±—ã —É–¥–∞–ª–µ–Ω–æ $count —Ñ–∞–π–ª–æ–≤ —Å—Ç–∞—Ä—à–µ $DAYS –¥–Ω–µ–π.${RESET}"
                log_message "INFO" "[DRY_RUN] Would delete $count files (age-based rotation, prefix=$PREFIX, days=$DAYS)"
                echo "$count"
                return 0
            fi
            echo -e "${YELLOW}–û—á–∏—Å—Ç–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ '$LABEL' (—É–¥–∞–ª–µ–Ω–∏–µ $count —Ñ–∞–π–ª–æ–≤ —Å—Ç–∞—Ä—à–µ $DAYS –¥–Ω–µ–π):${RESET}"
            for f in "${files[@]}"; do
                if [[ -f "$f" ]]; then
                    rm -f "$f"
                    rm -f "$f.version"
                    echo "  üóë –£–¥–∞–ª–µ–Ω: $(basename "$f")"
                    log_message "INFO" "Deleted $f (age-based rotation, prefix=$PREFIX, days=$DAYS)"
                fi
            done
            echo "$count"
            return 0
        else
            echo -e " $LABEL: –ù–∞–π–¥–µ–Ω–æ $count —Ñ–∞–π–ª–æ–≤ —Å—Ç–∞—Ä—à–µ $DAYS –¥–Ω–µ–π -> ${RED}–ö–∞–Ω–¥–∏–¥–∞—Ç—ã –Ω–∞ —É–¥–∞–ª–µ–Ω–∏–µ: $count —à—Ç.${RESET}"
            echo "$count"
            return 0
        fi
        return 0
    else
        if [[ "$PERFORM_DELETE" != "true" ]]; then
            echo -e " $LABEL: –ù–µ—Ç —Ñ–∞–π–ª–æ–≤ —Å—Ç–∞—Ä—à–µ $DAYS –¥–Ω–µ–π -> ${GREEN}OK${RESET}"
        fi
        echo "0"
        return 0
    fi
}

uninstall_script() {
    if [[ "$EUID" -ne 0 ]]; then
        print_message "ERROR" "Uninstall requires root (sudo)."
        return 1
    fi
    echo ""
    print_message "WARN" "–£–¥–∞–ª–µ–Ω–∏–µ —Å–∫—Ä–∏–ø—Ç–∞ –∏ –¥–∞–Ω–Ω—ã—Ö —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –±—É–¥–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–æ.";
    read -erp "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å? (y/N): " ans
    if [[ ! "$ans" =~ ^[Yy]$ ]]; then print_message "INFO" "–û—Ç–º–µ–Ω–µ–Ω–æ."; return 0; fi

    # remove symlink
    if [[ -L "$SYMLINK_PATH" ]]; then
        rm -f "$SYMLINK_PATH" && log_message "INFO" "Removed symlink $SYMLINK_PATH"
    fi
    # remove installed script
    if [[ -f "$INSTALL_DIR/$SCRIPT_NAME" ]]; then
        rm -f "$INSTALL_DIR/$SCRIPT_NAME" && log_message "INFO" "Removed $INSTALL_DIR/$SCRIPT_NAME"
    fi
    # remove config and backups (ask)
    if [[ -d "$INSTALL_DIR" ]]; then
        read -erp "–£–¥–∞–ª–∏—Ç—å –ø–∞–ø–∫—É $INSTALL_DIR –∏ –≤—Å–µ –±—ç–∫–∞–ø—ã? (y/N): " r2
        if [[ "$r2" =~ ^[Yy]$ ]]; then
            rm -rf "$INSTALL_DIR" && log_message "INFO" "Removed $INSTALL_DIR"
        else
            log_message "INFO" "Preserved $INSTALL_DIR"
        fi
    fi
    # try to remove cron entries
    crontab -l 2>/dev/null | grep -v "# LAZARUS-JOB-" | crontab - 2>/dev/null || true
    log_message "INFO" "Attempted to remove cron entries for lazarus"
    print_message "SUCCESS" "Uninstall finished."
}

# --- –ü–†–û–í–ï–†–ö–ê CRON –ó–ê–î–ê–ß ---

# –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Ä–µ–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ cron-–∑–∞–¥–∞—á –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å
get_cron_status() {
    local JOB_TYPE="$1"  # full, db, files
    local JOB_ID="# LAZARUS-JOB-${JOB_TYPE^^}"
    
    local cron_line=$(crontab -l 2>/dev/null | grep "$JOB_ID")
    
    if [[ -z "$cron_line" ]]; then
        echo "–í—ã–∫–ª"
        return
    fi
    
    # –ü–∞—Ä—Å–∏–º cron-—Å—Ç—Ä–æ–∫—É –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
    local minute=$(echo "$cron_line" | awk '{print $1}')
    local hour=$(echo "$cron_line" | awk '{print $2}')
    local day_month=$(echo "$cron_line" | awk '{print $3}')
    local month=$(echo "$cron_line" | awk '{print $4}')
    local day_week=$(echo "$cron_line" | awk '{print $5}')
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
    if [[ "$minute" == "0" && "$hour" == "*" ]]; then
        echo "–ï–∂–µ—á–∞—Å–Ω–æ"
    elif [[ "$minute" =~ ^\*/([0-9]+)$ ]]; then
        echo "–ö–∞–∂–¥—ã–µ ${BASH_REMATCH[1]} –º–∏–Ω"
    elif [[ "$minute" == "0" && "$hour" == "4" && "$day_week" == "1" ]]; then
        echo "–ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ"
    elif [[ "$minute" == "0" && "$hour" =~ ^[0-9]+$ && "$day_month" == "*" ]]; then
        printf "–ï–∂–µ–¥–Ω–µ–≤–Ω–æ %02d:00" "$hour"
    elif [[ "$hour" =~ ^[0-9]+$ && "$minute" =~ ^[0-9]+$ ]]; then
        printf "–ï–∂–µ–¥–Ω–µ–≤–Ω–æ %02d:%02d" "$hour" "$minute"
    else
        echo "–ê–∫—Ç–∏–≤–Ω–æ"
    fi
}

# –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–∫—Ä–∏–ø—Ç–∞ —Å —Ä–µ–∞–ª—å–Ω—ã–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º cron
sync_cron_with_config() {
    local CRON_FULL=$(get_cron_status "full")
    local CRON_DB=$(get_cron_status "db")
    local CRON_FILES=$(get_cron_status "files")
    
    local needs_save=false
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –µ—Å–ª–∏ –æ–Ω–∏ –æ—Ç–ª–∏—á–∞—é—Ç—Å—è –æ—Ç —Ä–µ–∞–ª—å–Ω–æ–≥–æ cron
    if [[ "$SCHEDULE_FULL" != "$CRON_FULL" ]]; then
        SCHEDULE_FULL="$CRON_FULL"
        needs_save=true
    fi
    if [[ "$SCHEDULE_DB" != "$CRON_DB" ]]; then
        SCHEDULE_DB="$CRON_DB"
        needs_save=true
    fi
    if [[ "$SCHEDULE_FILES" != "$CRON_FILES" ]]; then
        SCHEDULE_FILES="$CRON_FILES"
        needs_save=true
    fi
    
    if [[ "$needs_save" == "true" ]]; then
        save_config
    fi
}

# –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –º–µ–∂–¥—É –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏ –∏ cron, –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç –∏—Å–ø—Ä–∞–≤–∏—Ç—å
check_cron_mismatch() {
    [[ "$IS_INTERACTIVE" != "true" ]] && return 0
    
    local CRON_FULL=$(get_cron_status "full")
    local CRON_DB=$(get_cron_status "db")
    local CRON_FILES=$(get_cron_status "files")
    
    local mismatches=()
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º: –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –≤–∫–ª—é—á–µ–Ω–æ, –Ω–æ –≤ cron –Ω–µ—Ç
    if [[ "$SCHEDULE_FULL" != "–í—ã–∫–ª" && "$CRON_FULL" == "–í—ã–∫–ª" ]]; then
        mismatches+=("Full: –Ω–∞—Å—Ç—Ä–æ–π–∫–∞='$SCHEDULE_FULL', cron=–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç")
    fi
    if [[ "$SCHEDULE_DB" != "–í—ã–∫–ª" && "$CRON_DB" == "–í—ã–∫–ª" ]]; then
        mismatches+=("DB: –Ω–∞—Å—Ç—Ä–æ–π–∫–∞='$SCHEDULE_DB', cron=–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç")
    fi
    if [[ "$SCHEDULE_FILES" != "–í—ã–∫–ª" && "$CRON_FILES" == "–í—ã–∫–ª" ]]; then
        mismatches+=("Files: –Ω–∞—Å—Ç—Ä–æ–π–∫–∞='$SCHEDULE_FILES', cron=–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç")
    fi
    
    if [[ ${#mismatches[@]} -eq 0 ]]; then
        return 0
    fi
    
    clear_screen
    echo -e "${YELLOW}${BOLD}‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –∏ cron-–∑–∞–¥–∞—á${RESET}"
    echo ""
    echo "–í –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö —Å–∫—Ä–∏–ø—Ç–∞ —É–∫–∞–∑–∞–Ω—ã –∑–∞–¥–∞—á–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –±—ç–∫–∞–ø–∞,"
    echo "–Ω–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ cron-–∑–∞–¥–∞—á–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ —Å–∏—Å—Ç–µ–º–µ."
    echo ""
    echo -e "${CYAN}–ù–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è:${RESET}"
    for m in "${mismatches[@]}"; do
        echo -e " ‚Ä¢ $m"
    done
    echo ""
    echo "–í–æ–∑–º–æ–∂–Ω–æ, cron-–∑–∞–¥–∞—á–∏ –±—ã–ª–∏ —É–¥–∞–ª–µ–Ω—ã –≤—Ä—É—á–Ω—É—é."
    echo ""
    echo " 1. –°–æ–∑–¥–∞—Ç—å –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ cron-–∑–∞–¥–∞—á–∏ (–≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å)"
    echo " 2. –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å cron (—Å–±—Ä–æ—Å–∏—Ç—å –≤ '–í—ã–∫–ª')"
    echo " 0. –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (–æ—Å—Ç–∞–≤–∏—Ç—å –∫–∞–∫ –µ—Å—Ç—å)"
    echo ""
    read -erp "–í–∞—à –≤—ã–±–æ—Ä: " choice
    
    case $choice in
        1)
            # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º cron-–∑–∞–¥–∞—á–∏ –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫
            if [[ "$SCHEDULE_FULL" != "–í—ã–∫–ª" && "$CRON_FULL" == "–í—ã–∫–ª" ]]; then
                recreate_cron_from_schedule "full" "$SCHEDULE_FULL"
            fi
            if [[ "$SCHEDULE_DB" != "–í—ã–∫–ª" && "$CRON_DB" == "–í—ã–∫–ª" ]]; then
                recreate_cron_from_schedule "db" "$SCHEDULE_DB"
            fi
            if [[ "$SCHEDULE_FILES" != "–í—ã–∫–ª" && "$CRON_FILES" == "–í—ã–∫–ª" ]]; then
                recreate_cron_from_schedule "files" "$SCHEDULE_FILES"
            fi
            print_message "SUCCESS" "Cron-–∑–∞–¥–∞—á–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã."
            sleep 1
            ;;
        2)
            # –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å —Ä–µ–∞–ª—å–Ω—ã–º cron
            sync_cron_with_config
            print_message "SUCCESS" "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω—ã —Å cron."
            sleep 1
            ;;
        *)
            print_message "INFO" "–ü—Ä–æ–ø—É—â–µ–Ω–æ."
            sleep 0.5
            ;;
    esac
}

# –í–æ—Å—Å–æ–∑–¥–∞—ë—Ç cron-–∑–∞–¥–∞—á—É –∏–∑ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
recreate_cron_from_schedule() {
    local TASK_TYPE="$1"
    local SCHEDULE="$2"
    
    local JOB_CMD="$SYMLINK_PATH backup_$TASK_TYPE"
    [[ "$TASK_TYPE" == "db" ]] && JOB_CMD="$SYMLINK_PATH backup_db"
    [[ "$TASK_TYPE" == "files" ]] && JOB_CMD="$SYMLINK_PATH backup_files"
    [[ "$TASK_TYPE" == "full" ]] && JOB_CMD="$SYMLINK_PATH backup_full"
    
    local JOB_ID="# LAZARUS-JOB-${TASK_TYPE^^}"
    local NEW_CRON_LINE=""
    
    # –ü–∞—Ä—Å–∏–º —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∏ —Å–æ–∑–¥–∞—ë–º cron-—Å—Ç—Ä–æ–∫—É
    case "$SCHEDULE" in
        "–ï–∂–µ—á–∞—Å–Ω–æ")
            NEW_CRON_LINE="0 * * * * $JOB_CMD >> /var/log/lazarus_backup.log 2>&1 $JOB_ID"
            ;;
        "–ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ")
            NEW_CRON_LINE="0 4 * * 1 $JOB_CMD >> /var/log/lazarus_backup.log 2>&1 $JOB_ID"
            ;;
        –ï–∂–µ–¥–Ω–µ–≤–Ω–æ\ *)
            # –ü–∞—Ä—Å–∏–º –≤—Ä–µ–º—è –∏–∑ "–ï–∂–µ–¥–Ω–µ–≤–Ω–æ HH:MM" –∏–ª–∏ "–ï–∂–µ–¥–Ω–µ–≤–Ω–æ HH:00"
            local time_part="${SCHEDULE#–ï–∂–µ–¥–Ω–µ–≤–Ω–æ }"
            local hour="${time_part%%:*}"
            local minute="${time_part##*:}"
            hour=$((10#$hour))  # –£–±–∏—Ä–∞–µ–º –≤–µ–¥—É—â–∏–π –Ω–æ–ª—å
            minute=$((10#$minute))
            NEW_CRON_LINE="$minute $hour * * * $JOB_CMD >> /var/log/lazarus_backup.log 2>&1 $JOB_ID"
            ;;
        –ö–∞–∂–¥—ã–µ\ *\ –º–∏–Ω)
            local interval="${SCHEDULE#–ö–∞–∂–¥—ã–µ }"
            interval="${interval% –º–∏–Ω}"
            NEW_CRON_LINE="*/$interval * * * * $JOB_CMD >> /var/log/lazarus_backup.log 2>&1 $JOB_ID"
            ;;
        *)
            # –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
            print_message "WARN" "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ: $SCHEDULE"
            return 1
            ;;
    esac
    
    if [[ -n "$NEW_CRON_LINE" ]]; then
        local CURRENT_CRON=$(crontab -l 2>/dev/null | grep -v "$JOB_ID")
        echo -e "$CURRENT_CRON\n$NEW_CRON_LINE" | crontab -
        log_message "INFO" "Recreated cron job for $TASK_TYPE: $SCHEDULE"
    fi
}

# --- –ë–≠–ö–ê–ü ---

create_backup() {
    local TYPE="$1"
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –º–µ—Å—Ç–∞ (–º–∏–Ω–∏–º—É–º 1GB)
    local MIN_SPACE_MB=1024
    local free_space_kb=$(df -P "$BACKUP_DIR" 2>/dev/null | tail -1 | awk '{print $4}')
    local free_space_mb=$((free_space_kb / 1024))
    local free_space_human=$(df -h "$BACKUP_DIR" 2>/dev/null | tail -1 | awk '{print $4}')
    
    if [[ $free_space_mb -lt $MIN_SPACE_MB ]]; then
        print_message "ERROR" "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–µ—Å—Ç–∞ –Ω–∞ –¥–∏—Å–∫–µ! –°–≤–æ–±–æ–¥–Ω–æ: ${free_space_human} (–Ω—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 1GB)"
        log_message "ERROR" "Backup aborted: insufficient disk space (free=${free_space_human}, required=1GB)"
        if [[ "$IS_INTERACTIVE" == "true" ]]; then
            echo ""
            echo -e "${YELLOW}–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:${RESET}"
            echo " ‚Ä¢ –£–¥–∞–ª–∏—Ç–µ —Å—Ç–∞—Ä—ã–µ –±—ç–∫–∞–ø—ã (–º–µ–Ω—é 5)"
            echo " ‚Ä¢ –û—Å–≤–æ–±–æ–¥–∏—Ç–µ –º–µ—Å—Ç–æ –Ω–∞ –¥–∏—Å–∫–µ"
            echo ""
            read -erp "–í—Å—ë —Ä–∞–≤–Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å? (y/N): " force_continue
            if [[ ! "$force_continue" =~ ^[Yy]$ ]]; then
                return 1
            fi
            print_message "WARN" "–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –Ω–∞ —Å–≤–æ–π —Ä–∏—Å–∫..."
        else
            # –í non-interactive —Ä–µ–∂–∏–º–µ (cron) –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∏ –ø—Ä–µ—Ä—ã–≤–∞–µ–º
            send_telegram_notification "–ë—ç–∫–∞–ø –ø—Ä–µ—Ä–≤–∞–Ω: –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–µ—Å—Ç–∞ –Ω–∞ –¥–∏—Å–∫–µ (${free_space_human})"
            return 1
        fi
    fi
    
    # Health-check –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ –ø–µ—Ä–µ–¥ –±—ç–∫–∞–ø–æ–º
    if [[ "$TYPE" == "full" || "$TYPE" == "db_only" ]]; then
        if [[ -n "$DB_CONTAINER_NAME" ]]; then
            local db_running=$(docker container inspect -f '{{.State.Running}}' "$DB_CONTAINER_NAME" 2>/dev/null)
            if [[ "$db_running" != "true" ]]; then
                print_message "ERROR" "–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –ë–î ($DB_CONTAINER_NAME) –Ω–µ –∑–∞–ø—É—â–µ–Ω!"
                log_message "ERROR" "Backup aborted: DB container not running ($DB_CONTAINER_NAME)"
                if [[ "$IS_INTERACTIVE" != "true" ]]; then
                    send_telegram_notification "–ë—ç–∫–∞–ø –ø—Ä–µ—Ä–≤–∞–Ω: –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –ë–î –Ω–µ –∑–∞–ø—É—â–µ–Ω ($DB_CONTAINER_NAME)"
                fi
                return 1
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º health status –µ—Å–ª–∏ –µ—Å—Ç—å
            local db_health=$(docker container inspect -f '{{.State.Health.Status}}' "$DB_CONTAINER_NAME" 2>/dev/null)
            if [[ "$db_health" == "unhealthy" ]]; then
                print_message "WARN" "–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –ë–î –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ 'unhealthy'!"
                log_message "WARN" "DB container health status: unhealthy ($DB_CONTAINER_NAME)"
                if [[ "$IS_INTERACTIVE" == "true" ]]; then
                    read -erp "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ? (y/N): " cont_unhealthy
                    if [[ ! "$cont_unhealthy" =~ ^[Yy]$ ]]; then
                        return 1
                    fi
                fi
                # –í cron-—Ä–µ–∂–∏–º–µ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º, –Ω–æ –ª–æ–≥–∏—Ä—É–µ–º –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ
            fi
        fi
    fi
    
    if [[ -z "$BACKUP_PASSWORD" && "$IS_INTERACTIVE" == "true" ]]; then
        clear_screen
        echo -e "${RED}${BOLD}‚ö†Ô∏è –í–ù–ò–ú–ê–ù–ò–ï: –ü–∞—Ä–æ–ª—å —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!${RESET}"
        echo "–§–∞–π–ª –±—ç–∫–∞–ø–∞ –Ω–µ –±—É–¥–µ—Ç –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω. –î–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã —Ç—Ä–µ—Ç—å–∏–º –ª–∏—Ü–∞–º."
        echo ""
        echo " 1. –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –±–µ–∑ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è"
        echo " 2. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–∞—Ä–æ–ª—å —Å–µ–π—á–∞—Å"
        echo " 0. –û—Ç–º–µ–Ω–∞"
        echo ""
        read -erp "–í–∞—à –≤—ã–±–æ—Ä: " enc_choice
        case $enc_choice in
            1) ;; 
            2) read -s -erp "–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: " np
               echo ""; if [[ -n "$np" ]]; then BACKUP_PASSWORD="$np"; save_config; print_message "SUCCESS" "–ü–∞—Ä–æ–ª—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω."; else print_message "ERROR" "–ü—É—Å—Ç–æ–π –ø–∞—Ä–æ–ª—å. –û—Ç–º–µ–Ω–∞."; return; fi ;;
            *) print_message "INFO" "–ë—ç–∫–∞–ø –æ—Ç–º–µ–Ω–µ–Ω."; return ;;
        esac
    fi

    local TIMESTAMP=$(date +%Y-%m-%d"_"%H_%M_%S)
    local FILE_DB="db_${TIMESTAMP}.sql.gz"
    local FILE_DIR="dir_${TIMESTAMP}.tar.gz"
    local FILE_VERSION="bot_version.txt"
    local FILE_FINAL=""
    local HAS_ERROR=0
    local SKIP_INFO=""
    local SKIP_FILE="$BACKUP_DIR/skipped_files.txt"

    if [[ "$TYPE" != "db_only" ]]; then if ! ensure_bot_path; then return; fi; fi
    if [[ "$TYPE" == "db_only" || "$TYPE" == "full" ]]; then
        if [[ -z "$DB_CONTAINER_NAME" ]]; then ensure_bot_path; fi
    fi

    local CURRENT_VER=$(get_raw_bot_version)
    echo "${CURRENT_VER:-Unknown}" > "$BACKUP_DIR/$FILE_VERSION"

    if [[ "$TYPE" == "full" || "$TYPE" == "db_only" ]]; then
        print_message "INFO" "–î–∞–º–ø –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö ($DB_CONTAINER_NAME)..."
        if ! docker exec "$DB_CONTAINER_NAME" pg_dumpall -c -U "$DB_USER" 2>/dev/null | gzip -9 > "$BACKUP_DIR/$FILE_DB"; then
            print_message "ERROR" "–û—à–∏–±–∫–∞ –¥–∞–º–ø–∞ –ë–î."
            HAS_ERROR=1
        fi
    fi

    if [[ $HAS_ERROR -eq 1 ]]; then rm -f "$BACKUP_DIR/$FILE_DB" "$BACKUP_DIR/$FILE_VERSION"; return; fi

    IFS=' ' read -r -a EXCLUDE_ARRAY <<< "$EXCLUDE_DIRS"
    EXCLUDE_FLAGS=()
    for ex in "${EXCLUDE_ARRAY[@]}"; do if [[ -n "$ex" ]]; then EXCLUDE_FLAGS+=(--exclude="$ex"); fi; done
    EXCLUDE_FLAGS+=(--exclude="*.log" --exclude=".git" --exclude="private-remnawave-*.tar")

    if [[ "$TYPE" != "db_only" ]]; then
        : > "$SKIP_FILE"
        local FIND_CMD="find ."
        for ex in "${EXCLUDE_ARRAY[@]}"; do if [[ -n "$ex" ]]; then FIND_CMD+=" -path './$ex' -prune -o"; fi; done
        FIND_CMD+=" -type f -size +${MAX_FILE_SIZE_MB}M -print"
        cd "$BOT_PATH"; eval "$FIND_CMD" > "$SKIP_FILE"
        local SKIP_COUNT=$(wc -l < "$SKIP_FILE")
        if [[ "$SKIP_COUNT" -gt 0 ]]; then
            local SKIP_SIZE=$(du -ch --files0-from=<(tr '\n' '\0' < "$SKIP_FILE") | tail -1 | cut -f1)
            print_message "WARN" "–ü—Ä–æ–ø—É—â–µ–Ω–æ –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤ (>${MAX_FILE_SIZE_MB}MB): $SKIP_COUNT (–æ–±—â–∏–π –≤–µ—Å: $SKIP_SIZE)"
            EXCLUDE_FLAGS+=(--exclude-from="$SKIP_FILE")
            SKIP_INFO=$'\n‚ö†Ô∏è Skip: '"$SKIP_COUNT"$' (>'"$MAX_FILE_SIZE_MB"$'MB)'
        fi
    fi

    if [[ "$TYPE" == "db_only" ]]; then
        FILE_FINAL="lazarus_db_${TIMESTAMP}.tar.gz"
        tar -czf "$BACKUP_DIR/$FILE_FINAL" -C "$BACKUP_DIR" "$FILE_VERSION" "$FILE_DB"
        rm -f "$BACKUP_DIR/$FILE_DB"
    elif [[ "$TYPE" == "files_only" ]]; then
        FILE_FINAL="lazarus_files_${TIMESTAMP}.tar.gz"
        print_message "INFO" "–ê—Ä—Ö–∏–≤–∞—Ü–∏—è —Ñ–∞–π–ª–æ–≤ (—ç—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –≤—Ä–µ–º—è)..."
        tar -czf "$BACKUP_DIR/$FILE_FINAL" -C "$BACKUP_DIR" "$FILE_VERSION" "${EXCLUDE_FLAGS[@]}" -C "$(dirname "$BOT_PATH")" "$(basename "$BOT_PATH")"
    else 
        FILE_FINAL="lazarus_full_${TIMESTAMP}.tar.gz"
        print_message "INFO" "–ê—Ä—Ö–∏–≤–∞—Ü–∏—è —Ñ–∞–π–ª–æ–≤ (—ç—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –≤—Ä–µ–º—è)..."
        tar -czf "$BACKUP_DIR/$FILE_DIR" "${EXCLUDE_FLAGS[@]}" -C "$(dirname "$BOT_PATH")" "$(basename "$BOT_PATH")"
        tar -czf "$BACKUP_DIR/$FILE_FINAL" -C "$BACKUP_DIR" "$FILE_VERSION" "$FILE_DB" "$FILE_DIR"
        rm -f "$BACKUP_DIR/$FILE_DB" "$BACKUP_DIR/$FILE_DIR"
    fi

    rm -f "$SKIP_FILE"

    local ENC_STATUS="üîì Unencrypted"
    if [[ -z "$BACKUP_PASSWORD" && "$IS_INTERACTIVE" == "false" ]]; then ENC_STATUS="‚ö†Ô∏è NO PASSWORD"; fi

    if [[ -n "$BACKUP_PASSWORD" ]]; then
        print_message "INFO" "–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∞—Ä—Ö–∏–≤–∞ (—ç—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –≤—Ä–µ–º—è)..."
        # Pass password via env var to avoid process listing leak
        export LAZARUS_ENC_PASS="$BACKUP_PASSWORD"
        openssl enc -aes-256-cbc -salt -pbkdf2 -in "$BACKUP_DIR/$FILE_FINAL" -out "$BACKUP_DIR/${FILE_FINAL}.enc" -pass env:LAZARUS_ENC_PASS
        local enc_res=$?
        unset LAZARUS_ENC_PASS
        
        if [[ $enc_res -eq 0 ]]; then
            rm "$BACKUP_DIR/$FILE_FINAL"
            FILE_FINAL="${FILE_FINAL}.enc"
            ENC_STATUS="üîí Encrypted"
            print_message "SUCCESS" "–ê—Ä—Ö–∏–≤ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω."
        else
            print_message "ERROR" "–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è! –û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–µ–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞."
        fi
    fi

    local FINAL_VERSION_FILE="$BACKUP_DIR/$FILE_FINAL.version"
    cp "$BACKUP_DIR/$FILE_VERSION" "$FINAL_VERSION_FILE"
    rm -f "$BACKUP_DIR/$FILE_VERSION"
    
    # --- VERIFY ARCHIVE ---
    print_message "INFO" "–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ –∞—Ä—Ö–∏–≤–∞..."
    local VERIFY_OK="false"
    if [[ "$FILE_FINAL" == *".enc" ]]; then
        # For encrypted files, we can't easily verify without decrypting. 
        # We assume openssl exit code 0 was enough, or we could decrypt to /dev/null
        export LAZARUS_VERIFY_PASS="$BACKUP_PASSWORD"
        if openssl enc -d -aes-256-cbc -pbkdf2 -in "$BACKUP_DIR/$FILE_FINAL" -pass env:LAZARUS_VERIFY_PASS | gzip -t 2>/dev/null; then
             VERIFY_OK="true"
        fi
        unset LAZARUS_VERIFY_PASS
    else
        if gzip -t "$BACKUP_DIR/$FILE_FINAL" 2>/dev/null; then
             VERIFY_OK="true"
        fi
    fi

    if [[ "$VERIFY_OK" == "true" ]]; then
        print_message "SUCCESS" "–ê—Ä—Ö–∏–≤ –≤–∞–ª–∏–¥–µ–Ω."
    else
        print_message "ERROR" "–ê—Ä—Ö–∏–≤ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω! (Verification failed)"
        # We do not delete it, just warn
    fi

    local SIZE=$(du -h "$BACKUP_DIR/$FILE_FINAL" | awk '{print $1}')
    print_message "SUCCESS" "–ë—ç–∫–∞–ø —Å–æ–∑–¥–∞–Ω: $FILE_FINAL ($SIZE)"
    log_message "SUCCESS" "Backup created: $FILE_FINAL (type=$TYPE, size=$SIZE, enc_status=$ENC_STATUS, verify=$VERIFY_OK)"

    upload_to_remote "$BACKUP_DIR/$FILE_FINAL"
    
    local DISPLAY_DATE=$(date "+%d.%m.%Y %H:%M:%S")
    local HASHTAG=""; local TYPE_NAME=""; local ROTATION_KEY=""
    
    case "$TYPE" in
        "full") HASHTAG="üíæ #full_backup"; TYPE_NAME="üì¶ –ü–æ–ª–Ω—ã–π –±—ç–∫–∞–ø"; ROTATION_KEY="–ü–æ–ª–Ω—ã–µ –±—ç–∫–∞–ø—ã" ;;
        "db_only") HASHTAG="üíæ #db_only"; TYPE_NAME="üóÑ –î–∞–º–ø –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"; ROTATION_KEY="–ë–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö" ;;
        "files_only") HASHTAG="üíæ #files_only"; TYPE_NAME="üìÇ –§–∞–π–ª—ã –±–æ—Ç–∞"; ROTATION_KEY="–ê—Ä—Ö–∏–≤—ã —Ñ–∞–π–ª–æ–≤" ;;
    esac

    local VER_MSG=""; [[ -n "$CURRENT_VER" ]] && VER_MSG=" | üè∑ v${CURRENT_VER}"
    local CAPTION="${HASHTAG}
üìÖ ${DISPLAY_DATE}
${TYPE_NAME}
üìè ${SIZE}${VER_MSG}
${ENC_STATUS}${REMOTE_UPLOAD_STATUS_TEXT}${SKIP_INFO}"
    
    send_telegram_document "$BACKUP_DIR/$FILE_FINAL" "$CAPTION"

    rotate_backups_by_count "lazarus_$TYPE" "$ROTATION_KEY" "true"
}

# --- –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ò–ï ---

select_backup_file() {
    local FILTER_PREFIX="$1"; local TITLE="$2"
    local show_limit=5; local show_filenames=false

    while true; do
        local files_raw=("$BACKUP_DIR/${FILTER_PREFIX}_"*.tar.gz*)
        local valid_files=()
        for f in "${files_raw[@]}"; do
            if [[ ! -e "$f" ]]; then continue; fi 
            if [[ "$f" == *".version" ]]; then continue; fi
            if [[ ! "$f" =~ \.tar\.gz(\.enc)?$ ]]; then continue; fi
            valid_files+=("$f")
        done
        
        local total_count=${#valid_files[@]}
        
        if [[ "$total_count" -eq 0 ]]; then
            print_message "WARN" "–§–∞–π–ª–æ–≤ —Ç–∏–ø–∞ '${TITLE}' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ."; read -erp "Enter..." dummy; return 1
        fi
        
        IFS=$'\n' sorted_backups=($(sort -r <<<"${valid_files[*]}"))
        unset IFS
        
        local CURRENT_VER=$(get_raw_bot_version)

        clear_screen; echo -e "${GREEN}–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ: ${BOLD}${TITLE}${RESET}"
        echo -e "–í—Å–µ–≥–æ —Ñ–∞–π–ª–æ–≤: ${CYAN}${total_count}${RESET}"; echo ""

        local loop_limit=$show_limit
        if [[ $loop_limit -gt $total_count ]]; then loop_limit=$total_count; fi

        for (( i=0; i<loop_limit; i++ )); do
            local file="${sorted_backups[$i]}"
            local filename=$(basename "$file")
            
            local CACHE_FILE="${file}.version"
            local B_VER=""
            if [[ -f "$CACHE_FILE" ]]; then B_VER=$(cat "$CACHE_FILE")
            else
                if [[ "$file" != *".enc" ]]; then
                    B_VER=$(tar -xzf "$file" -O bot_version.txt 2>/dev/null)
                fi
                if [[ -n "$B_VER" ]]; then echo "$B_VER" > "$CACHE_FILE"; else echo "?" > "$CACHE_FILE"; B_VER="?"; fi
            fi
            
            local ENC_MARK=""; [[ "$file" == *".enc" ]] && ENC_MARK="${RED}[ENC]${RESET} "
            
            local VER_STR=""
            if [[ "$B_VER" == "Unknown" || "$B_VER" == "" ]]; then VER_STR="${GRAY}[–ù/–î]${RESET}"
            elif [[ "$B_VER" == "?" ]]; then VER_STR="${GRAY}[Legacy]${RESET}"
            elif [[ -z "$CURRENT_VER" ]]; then VER_STR="${GRAY}[v$B_VER]${RESET}"
            elif [[ "$B_VER" == "$CURRENT_VER" ]]; then VER_STR="${GREEN}[v$B_VER]${RESET}"
            else VER_STR="${RED}[v$B_VER]${RESET}"; fi

            if [[ "$show_filenames" == "true" ]]; then
                printf " %2d. %s%s %s\n" "$((i+1))" "$ENC_MARK" "$filename" "$VER_STR"
            else
                if [[ $filename =~ _([0-9]{4}-[0-9]{2}-[0-9]{2})_([0-9]{2})_([0-9]{2}) ]]; then
                    local date_part="${BASH_REMATCH[1]}"
                    local time_part="${BASH_REMATCH[2]}:${BASH_REMATCH[3]}"
                    local d_d=${date_part:8:2}; local d_m=${date_part:5:2}
                    local pretty_date="$d_d.$d_m $time_part"
                    local fsize=$(du -h "$file" | awk '{print $1}')
                    printf " %2d. %s | %5s | %s%s\n" "$((i+1))" "${BOLD}$pretty_date${RESET}" "$fsize" "$ENC_MARK" "$VER_STR"
                else
                    printf " %2d. %s %s\n" "$((i+1))" "$filename" "$VER_STR"
                fi
            fi
        done

        echo ""
        if [[ $total_count -gt 5 ]]; then
            if [[ $loop_limit -lt $total_count ]]; then
                 echo -e " ${MAGENTA}888. –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ ($total_count —à—Ç)${RESET}"
            else
                 echo -e " ${MAGENTA}888. –°–≤–µ—Ä–Ω—É—Ç—å —Å–ø–∏—Å–æ–∫ (–ø–æ–∫–∞–∑–∞—Ç—å 5)${RESET}"
            fi
        fi

        if [[ "$show_filenames" == "false" ]]; then
            echo -e " 999. –ü–æ–∫–∞–∑–∞—Ç—å –∏–º–µ–Ω–∞ —Ñ–∞–π–ª–æ–≤"; 
        else
            echo -e " 999. –ü–æ–∫–∞–∑–∞—Ç—å –¥–∞—Ç—É –∏ —Ä–∞–∑–º–µ—Ä"; 
        fi
        echo " 0. –ù–∞–∑–∞–¥"; echo ""
        read -erp "–ù–æ–º–µ—Ä —Ñ–∞–π–ª–∞ –∏–ª–∏ –∫–æ–º–∞–Ω–¥–∞ (Enter - –ù–∞–∑–∞–¥): " choice
        
        if [[ -z "$choice" || "$choice" == "0" ]]; then return 1
        elif [[ "$choice" == "888" ]]; then 
            if [[ $loop_limit -lt $total_count ]]; then loop_limit=$total_count; else loop_limit=5; fi
            show_limit=$loop_limit
            continue
        elif [[ "$choice" == "999" ]]; then 
            if [[ "$show_filenames" == "false" ]]; then show_filenames=true; else show_filenames=false; fi
            continue
        elif [[ "$choice" =~ ^[0-9]+$ && "$choice" -ge 1 && "$choice" -le "$total_count" ]]; then SELECTED_FILE="${sorted_backups[$((choice-1))]}"; return 0
        else print_message "ERROR" "–ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä."; sleep 1; fi
    done
}

execute_restore() {
    local MODE="$1"; local FILE="$2"
    echo ""; print_message "WARN" "–í–ù–ò–ú–ê–ù–ò–ï: –¢–µ–∫—É—â–∏–µ –¥–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞–Ω—ã!"
    read -erp "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å? (y/n): " confirm; [[ "$confirm" != "y" ]] && return

    local TMP_DIR="$BACKUP_DIR/restore_tmp_$$"
    mkdir -p "$TMP_DIR"
    
    local WORK_FILE="$FILE"
    if [[ "$FILE" == *".enc" ]]; then
        print_message "INFO" "–§–∞–π–ª –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω. –¢—Ä–µ–±—É–µ—Ç—Å—è –ø–∞—Ä–æ–ª—å."
        read -s -erp "–ü–∞—Ä–æ–ª—å: " decrypt_pass; echo ""
        local DECRYPTED_FILE="$TMP_DIR/decrypted.tar.gz"
        
        export LAZARUS_DEC_PASS="$decrypt_pass"
        openssl enc -d -aes-256-cbc -pbkdf2 -in "$FILE" -out "$DECRYPTED_FILE" -pass env:LAZARUS_DEC_PASS 2>/dev/null
        local dec_res=$?
        unset LAZARUS_DEC_PASS

        if [[ $dec_res -ne 0 ]]; then print_message "ERROR" "–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å –∏–ª–∏ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–Ω—ã–π —Ñ–∞–π–ª!"; rm -rf "$TMP_DIR"; return; fi
        print_message "SUCCESS" "–ü–∞—Ä–æ–ª—å –ø—Ä–∏–Ω—è—Ç."
        WORK_FILE="$DECRYPTED_FILE"
    fi

    print_message "INFO" "–†–∞—Å–ø–∞–∫–æ–≤–∫–∞..."
    tar -xzf "$WORK_FILE" -C "$TMP_DIR"

    local DB_DUMP=$(find "$TMP_DIR" -name "db_*.sql.gz" | head -1)
    local DIR_ARC=$(find "$TMP_DIR" -name "dir_*.tar.gz" | head -1)

    if [[ "$MODE" == "full" && -n "$DIR_ARC" ]]; then
        if ! ensure_bot_path; then rm -rf "$TMP_DIR"; return; fi
        print_message "INFO" "–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤..."
        cd "$BOT_PATH" && docker compose down 2>/dev/null
        print_message "INFO" "–û—á–∏—Å—Ç–∫–∞ –ø–∞–ø–∫–∏..."
        rm -rf "$BOT_PATH"/*
        print_message "INFO" "–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ñ–∞–π–ª–æ–≤..."
        tar -xzf "$DIR_ARC" -C "$(dirname "$BOT_PATH")"
        docker volume rm "$DB_VOLUME_NAME" 2>/dev/null || true
        print_message "INFO" "–ó–∞–ø—É—Å–∫ –ë–î..."
        docker compose up -d "$DB_SERVICE_NAME"
        sleep 5
    fi

    if [[ -n "$DB_DUMP" ]]; then
        print_message "INFO" "–ò–º–ø–æ—Ä—Ç –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö..."
        if ! ensure_bot_path; then rm -rf "$TMP_DIR"; return; fi 
        zcat "$DB_DUMP" | docker exec -i "$DB_CONTAINER_NAME" psql -U "$DB_USER" -d postgres >/dev/null 2>&1
    fi

    if [[ "$MODE" == "full" ]]; then
        print_message "INFO" "–ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤..."
        cd "$BOT_PATH" && docker compose up -d
    fi

    rm -rf "$TMP_DIR"
    print_message "SUCCESS" "–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ."
    log_message "SUCCESS" "Restore completed (mode=$MODE, file=$FILE)"
    read -erp "–ù–∞–∂–º–∏—Ç–µ Enter..." dummy
}

# --- –ú–ï–ù–Æ–®–ö–ò ---

menu_manual_backup() {
    while true; do
        clear_screen; echo -e "${GREEN}–°–æ–∑–¥–∞–Ω–∏–µ —Ä—É—á–Ω–æ–≥–æ –±—ç–∫–∞–ø–∞${RESET}"
        echo " 1. –ü–æ–ª–Ω—ã–π –±—ç–∫–∞–ø (–ë–î + –§–∞–π–ª—ã)"
        echo " 2. –¢–æ–ª—å–∫–æ –ë–î"
        echo " 3. –¢–æ–ª—å–∫–æ –§–∞–π–ª—ã"
        echo " 0. –ù–∞–∑–∞–¥"
        echo ""
        read -erp "–í–∞—à –≤—ã–±–æ—Ä (Enter - –ù–∞–∑–∞–¥): " m_choice
        [[ -z "$m_choice" ]] && return
        case $m_choice in
            1) create_backup "full"; read -erp "Enter..." dummy; return ;;
            2) create_backup "db_only"; read -erp "Enter..." dummy; return ;;
            3) create_backup "files_only"; read -erp "Enter..." dummy; return ;;
            0) return ;;
        esac
    done
}

menu_restore() {
    while true; do
        # –°–¢–†–û–ì–ê–Ø –õ–û–ì–ò–ö–ê –ü–û–î–°–ß–ï–¢–ê
        local n_full=$(find "$BACKUP_DIR" -type f \( -name "lazarus_full_*.tar.gz" -o -name "lazarus_full_*.tar.gz.enc" \) 2>/dev/null | wc -l)
        local n_db=$(find "$BACKUP_DIR" -type f \( -name "lazarus_db_*.tar.gz" -o -name "lazarus_db_*.tar.gz.enc" \) 2>/dev/null | wc -l)
        local n_files=$(find "$BACKUP_DIR" -type f \( -name "lazarus_files_*.tar.gz" -o -name "lazarus_files_*.tar.gz.enc" \) 2>/dev/null | wc -l)

        local c_f="$CYAN"; [[ "$n_full" == "0" ]] && c_f="$GRAY"
        local c_d="$CYAN"; [[ "$n_db" == "0" ]] && c_d="$GRAY"
        local c_fl="$CYAN"; [[ "$n_files" == "0" ]] && c_fl="$GRAY"

        clear_screen; echo -e "${GREEN}–ú–µ–Ω—é –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è${RESET}"
        echo -e " 1. –ü–æ–ª–Ω—ã–π –±—ç–∫–∞–ø      ${c_f}[${n_full} —à—Ç]${RESET}"
        echo -e " 2. –¢–æ–ª—å–∫–æ –ë–î         ${c_d}[${n_db} —à—Ç]${RESET}"
        echo -e " 3. –¢–æ–ª—å–∫–æ –§–∞–π–ª—ã      ${c_fl}[${n_files} —à—Ç]${RESET}"
        echo " 0. –ù–∞–∑–∞–¥"
        echo ""
        read -erp "–í—ã–±–æ—Ä (Enter - –ù–∞–∑–∞–¥): " r_choice
        [[ -z "$r_choice" ]] && return

        local SELECTED_FILE=""
        case $r_choice in
            1) if select_backup_file "lazarus_full" "–ü–æ–ª–Ω—ã–µ –±—ç–∫–∞–ø—ã"; then execute_restore "full" "$SELECTED_FILE"; fi ;;
            2) if select_backup_file "lazarus_db" "–ë—ç–∫–∞–ø—ã –ë–î"; then execute_restore "db_only" "$SELECTED_FILE"; fi ;;
            3) if select_backup_file "lazarus_files" "–ë—ç–∫–∞–ø—ã –§–∞–π–ª–æ–≤"; then 
                   echo ""; print_message "WARN" "–ë—É–¥—É—Ç –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞–Ω—ã —Ñ–∞–π–ª—ã –≤ –ø–∞–ø–∫–µ –±–æ—Ç–∞!"
                   read -erp "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å? (y/n): " cf
                   if [[ "$cf" == "y" ]]; then 
                       if ensure_bot_path; then tar -xzf "$SELECTED_FILE" -C "$(dirname "$BOT_PATH")"; print_message "SUCCESS" "–§–∞–π–ª—ã —Ä–∞—Å–ø–∞–∫–æ–≤–∞–Ω—ã."; read -erp "Enter..." dummy; fi
                   fi
               fi ;;
            0) return ;;
        esac
    done
}

setup_cron_task() {
    local TASK_TYPE="$1"; local JOB_CMD=""; local JOB_ID=""
    if [[ "$TASK_TYPE" == "db" ]]; then JOB_CMD="$SYMLINK_PATH backup_db"; JOB_ID="# LAZARUS-JOB-DB"
    elif [[ "$TASK_TYPE" == "files" ]]; then if ! ensure_bot_path; then return; fi; JOB_CMD="$SYMLINK_PATH backup_files"; JOB_ID="# LAZARUS-JOB-FILES"
    elif [[ "$TASK_TYPE" == "full" ]]; then if ! ensure_bot_path; then return; fi; JOB_CMD="$SYMLINK_PATH backup_full"; JOB_ID="# LAZARUS-JOB-FULL"; fi

    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å
    local CURRENT_STATUS=$(get_cron_status "$TASK_TYPE")
    local STATUS_COLOR="$GRAY"; [[ "$CURRENT_STATUS" != "–í—ã–∫–ª" ]] && STATUS_COLOR="$YELLOW"
    
    # –ß–µ–ª–æ–≤–µ–∫–æ—á–∏—Ç–∞–µ–º–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–∏–ø–∞
    local TYPE_NAME=""
    case "$TASK_TYPE" in
        "full") TYPE_NAME="–ü–æ–ª–Ω—ã–π –±—ç–∫–∞–ø" ;;
        "db") TYPE_NAME="–¢–æ–ª—å–∫–æ –ë–î" ;;
        "files") TYPE_NAME="–¢–æ–ª—å–∫–æ –§–∞–π–ª—ã" ;;
    esac

    clear_screen
    echo -e "${GREEN}${BOLD}–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: ${TYPE_NAME}${RESET}"
    echo -e "–¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å: [${STATUS_COLOR}${CURRENT_STATUS}${RESET}]"
    echo ""
    echo -e " 1. –ï–∂–µ—á–∞—Å–Ω–æ          ${GRAY}[–≤ :00]${RESET}"
    echo -e " 2. –ï–∂–µ–¥–Ω–µ–≤–Ω–æ         ${GRAY}[–≤ 04:00]${RESET}"
    echo -e " 3. –ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ       ${GRAY}[–ü–Ω –≤ 04:00]${RESET}"
    echo -e " 4. –°–≤–æ—ë –≤—Ä–µ–º—è        ${GRAY}[–ß–ß:–ú–ú]${RESET}"
    echo -e " 5. –ö–∞–∂–¥—ã–µ N –º–∏–Ω—É—Ç    ${GRAY}[1-59]${RESET}"
    echo ""
    if [[ "$CURRENT_STATUS" != "–í—ã–∫–ª" ]]; then
        echo -e " ${RED}0. –û—Ç–∫–ª—é—á–∏—Ç—å${RESET}"
    else
        echo " 0. –ù–∞–∑–∞–¥"
    fi
    echo ""
    read -erp "–í—ã–±–æ—Ä (Enter - –ù–∞–∑–∞–¥): " c
    [[ -z "$c" ]] && return
    
    local NEW_CRON_LINES=""; local DISPLAY_TIME=""

    case $c in
        1) NEW_CRON_LINES="0 * * * * $JOB_CMD >> /var/log/lazarus_backup.log 2>&1 $JOB_ID"; DISPLAY_TIME="–ï–∂–µ—á–∞—Å–Ω–æ" ;;
        2) NEW_CRON_LINES="0 4 * * * $JOB_CMD >> /var/log/lazarus_backup.log 2>&1 $JOB_ID"; DISPLAY_TIME="–ï–∂–µ–¥–Ω–µ–≤–Ω–æ 04:00" ;;
        3) NEW_CRON_LINES="0 4 * * 1 $JOB_CMD >> /var/log/lazarus_backup.log 2>&1 $JOB_ID"; DISPLAY_TIME="–ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ" ;;
        4) 
           echo ""
           echo "–í–≤–µ–¥–∏—Ç–µ –≤—Ä–µ–º—è (–ß–ß:–ú–ú), –º–æ–∂–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª:"
           echo -e "${GRAY}–ü—Ä–∏–º–µ—Ä: 09:00 18:30${RESET}"
           read -erp "> " times_input
           if [[ -z "$times_input" ]]; then print_message "ERROR" "–í—Ä–µ–º—è –Ω–µ –≤–≤–µ–¥–µ–Ω–æ!"; sleep 1; return; fi
           for t in $times_input; do 
               if [[ "$t" =~ ^([0-9]{1,2}):([0-9]{1,2})$ ]]; then 
                   h=$((10#${BASH_REMATCH[1]})); m=$((10#${BASH_REMATCH[2]}))
                   NEW_CRON_LINES+="$m $h * * * $JOB_CMD >> /var/log/lazarus_backup.log 2>&1 $JOB_ID"$'\n'
               fi
           done
           DISPLAY_TIME="–°–≤–æ–µ: $times_input" ;;
        5) 
           echo ""
           echo "–í–≤–µ–¥–∏—Ç–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª –≤ –º–∏–Ω—É—Ç–∞—Ö (1-59):"
           read -erp "> " interval
           if [[ "$interval" =~ ^[0-9]+$ ]] && [ "$interval" -gt 0 ] && [ "$interval" -lt 60 ]; then
               NEW_CRON_LINES="*/$interval * * * * $JOB_CMD >> /var/log/lazarus_backup.log 2>&1 $JOB_ID"
               DISPLAY_TIME="–ö–∞–∂–¥—ã–µ $interval –º–∏–Ω"
           else print_message "ERROR" "–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 59."; sleep 1; return; fi ;;
        0) 
           if [[ "$CURRENT_STATUS" != "–í—ã–∫–ª" ]]; then
               DISPLAY_TIME="–í—ã–∫–ª"
           else
               return
           fi ;;
        *) return ;;
    esac

    local CURRENT_CRON=$(crontab -l 2>/dev/null | grep -v "$JOB_ID")
    if [[ "$DISPLAY_TIME" != "–í—ã–∫–ª" && -n "$NEW_CRON_LINES" ]]; then echo -e "$CURRENT_CRON\n$NEW_CRON_LINES" | crontab -
    else echo "$CURRENT_CRON" | crontab -; fi

    # –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å —Ä–µ–∞–ª—å–Ω—ã–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º cron
    sync_cron_with_config
    
    log_message "INFO" "Cron task updated: $TASK_TYPE -> $DISPLAY_TIME"
    print_message "SUCCESS" "–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ!"; sleep 1
}

menu_automation() {
    while true; do
        # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ —Å—Ç–∞—Ç—É—Å—ã –∏–∑ cron
        local CRON_FULL=$(get_cron_status "full")
        local CRON_DB=$(get_cron_status "db")
        local CRON_FILES=$(get_cron_status "files")
        
        # –¶–≤–µ—Ç–æ–≤–∞—è –∏–Ω–¥–∏–∫–∞—Ü–∏—è: –∂—ë–ª—Ç—ã–π –µ—Å–ª–∏ –∞–∫—Ç–∏–≤–µ–Ω, —Å–µ—Ä—ã–π –µ—Å–ª–∏ –≤—ã–∫–ª—é—á–µ–Ω
        local COLOR_FULL="$GRAY"; [[ "$CRON_FULL" != "–í—ã–∫–ª" ]] && COLOR_FULL="$YELLOW"
        local COLOR_DB="$GRAY"; [[ "$CRON_DB" != "–í—ã–∫–ª" ]] && COLOR_DB="$YELLOW"
        local COLOR_FILES="$GRAY"; [[ "$CRON_FILES" != "–í—ã–∫–ª" ]] && COLOR_FILES="$YELLOW"
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ —Ö–æ—Ç—å –æ–¥–∏–Ω –∞–∫—Ç–∏–≤–Ω—ã–π –∞–≤—Ç–æ-–±—ç–∫–∞–ø
        local HAS_ANY_CRON=false
        [[ "$CRON_FULL" != "–í—ã–∫–ª" || "$CRON_DB" != "–í—ã–∫–ª" || "$CRON_FILES" != "–í—ã–∫–ª" ]] && HAS_ANY_CRON=true
        
        clear_screen
        echo -e "${GREEN}${BOLD}–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ë—ç–∫–∞–ø–∞${RESET}"
        echo ""
        echo -e " 1. –ü–æ–ª–Ω—ã–π –±—ç–∫–∞–ø  [${COLOR_FULL}${CRON_FULL}${RESET}]"
        echo -e " 2. –¢–æ–ª—å–∫–æ –ë–î     [${COLOR_DB}${CRON_DB}${RESET}]"
        echo -e " 3. –¢–æ–ª—å–∫–æ –§–∞–π–ª—ã  [${COLOR_FILES}${CRON_FILES}${RESET}]"
        echo ""
        if [[ "$HAS_ANY_CRON" == true ]]; then
            echo -e " ${RED}9. –û—Ç–∫–ª—é—á–∏—Ç—å –≤—Å–µ –∞–≤—Ç–æ-–±—ç–∫–∞–ø—ã${RESET}"
            echo ""
        fi
        echo " 0. –ù–∞–∑–∞–¥"
        echo ""
        read -erp "–í—ã–±–æ—Ä (Enter - –ù–∞–∑–∞–¥): " ac
        [[ -z "$ac" ]] && return
        case $ac in
            1) setup_cron_task "full" ;;
            2) setup_cron_task "db" ;;
            3) setup_cron_task "files" ;;
            9) 
                if [[ "$HAS_ANY_CRON" == true ]]; then
                    disable_all_cron_tasks
                fi
                ;;
            0) return ;;
        esac
    done
}

# –û—Ç–∫–ª—é—á–µ–Ω–∏–µ –≤—Å–µ—Ö cron-–∑–∞–¥–∞—á LAZARUS
disable_all_cron_tasks() {
    echo ""
    print_message "WARN" "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ—Ç–∫–ª—é—á–∏—Ç—å –í–°–ï –∞–≤—Ç–æ-–±—ç–∫–∞–ø—ã?"
    read -erp "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å? (y/n): " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        # –£–¥–∞–ª—è–µ–º –≤—Å–µ cron-–∑–∞–¥–∞—á–∏ LAZARUS
        local current_cron
        current_cron=$(crontab -l 2>/dev/null || echo "")
        local new_cron
        new_cron=$(echo "$current_cron" | grep -v "# LAZARUS-JOB-")
        
        if [[ -z "$new_cron" ]]; then
            crontab -r 2>/dev/null || true
        else
            echo "$new_cron" | crontab -
        fi
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–Ω—Ñ–∏–≥
        SCHEDULE_FULL="–í—ã–∫–ª"
        SCHEDULE_DB="–í—ã–∫–ª"
        SCHEDULE_FILES="–í—ã–∫–ª"
        save_config
        
        print_message "SUCCESS" "–í—Å–µ –∞–≤—Ç–æ-–±—ç–∫–∞–ø—ã –æ—Ç–∫–ª—é—á–µ–Ω—ã"
        log_message "INFO" "All LAZARUS cron tasks disabled by user"
        sleep 1.5
    else
        print_message "INFO" "–û—Ç–º–µ–Ω–µ–Ω–æ"
        sleep 1
    fi
}

menu_settings() {
    while true; do
        clear_screen; echo -e "${GREEN}${BOLD}–ù–∞—Å—Ç—Ä–æ–π–∫–∏${RESET}"
        
        local MASKED_TOKEN="${BOT_TOKEN:0:5}.......${BOT_TOKEN: -5}"; [[ ${#BOT_TOKEN} -lt 10 ]] && MASKED_TOKEN="*******"
        local PASS_MASK="–ù–µ—Ç"; [[ -n "$BACKUP_PASSWORD" ]] && PASS_MASK="********"
        
        # –ú–∞—Å–∫–∏—Ä—É–µ–º Chat ID (–ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 4 –∏ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 3 —Å–∏–º–≤–æ–ª–∞)
        local MASKED_CHAT_ID="-"
        if [[ -n "$CHAT_ID" ]]; then
            if [[ ${#CHAT_ID} -gt 8 ]]; then
                MASKED_CHAT_ID="${CHAT_ID:0:4}...${CHAT_ID: -3}"
            else
                MASKED_CHAT_ID="*****"
            fi
        fi
        
        local MASKED_REMOTE_USER="-"
        if [[ -n "$REMOTE_STORAGE_USER" ]]; then
            if [[ ${#REMOTE_STORAGE_USER} -gt 4 ]]; then
                MASKED_REMOTE_USER="${REMOTE_STORAGE_USER:0:3}...${REMOTE_STORAGE_USER: -2}"
            else
                MASKED_REMOTE_USER="*****"
            fi
        fi

        # –°—Ç–∞—Ç—É—Å—ã
        local ST_TG_NOTIFY="${RED}–í—ã–∫–ª${RESET}"; [[ "$SEND_TO_TELEGRAM" == "true" ]] && ST_TG_NOTIFY="${GREEN}–í–∫–ª${RESET}"
        local ST_TG_FILE="${RED}–í—ã–∫–ª${RESET}"; [[ "$TG_SEND_FILE" == "true" ]] && ST_TG_FILE="${GREEN}–í–∫–ª${RESET}"
        local ST_REM="${RED}–í—ã–∫–ª${RESET}"; [[ "$SEND_TO_REMOTE" == "true" ]] && ST_REM="${GREEN}–í–∫–ª${RESET}"
        
        local STORAGE_TYPE_DISP="–í—ã–∫–ª"
        if [[ "$REMOTE_STORAGE_TYPE" != "off" ]]; then STORAGE_TYPE_DISP="${REMOTE_STORAGE_TYPE^^}"; fi

        echo -e "${CYAN}--- –û–ë–©–ò–ï ---${RESET}"
        echo -e " 1. –ü—É—Ç—å –∫ –±–æ—Ç—É:        ${GRAY}${BOT_PATH}${RESET}"
        echo -e " 2. –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –±–æ—Ç–∞:     ${GRAY}${BOT_CONTAINER_NAME}${RESET}"
        echo -e " 3. –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –ë–î:       ${GRAY}${DB_CONTAINER_NAME}${RESET}"
        echo -e " 4. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ë–î:    ${GRAY}${DB_USER}${RESET}"
        echo -e " 5. –ú–∞–∫—Å. –±—ç–∫–∞–ø–æ–≤:      ${GRAY}${MAX_BACKUPS_COUNT} —à—Ç.${RESET}"
        echo -e " 6. –ò—Å–∫–ª—é—á–∏—Ç—å –ø–∞–ø–∫–∏:    ${GRAY}${EXCLUDE_DIRS:-–ù–µ—Ç}${RESET}"
        echo -e " 7. –ú–∞–∫—Å. —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞: ${GRAY}${MAX_FILE_SIZE_MB} MB${RESET}"
        
        echo -e "\n${CYAN}--- TELEGRAM ---${RESET}"
        echo -e " 8.  Token:             ${GRAY}${MASKED_TOKEN}${RESET}"
        echo -e " 9.  Chat ID:           ${GRAY}${MASKED_CHAT_ID}${RESET}"
        echo -e " 10. Thread ID:         ${GRAY}${TG_MESSAGE_THREAD_ID:-–ù–µ—Ç}${RESET}"
        echo -e " 11. –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:       $ST_TG_NOTIFY"
        echo -e " 12. –û—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–∞–π–ª–∞:    $ST_TG_FILE"
        echo -e " 13. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–≤—è–∑—å"

        echo -e "\n${CYAN}--- –£–î–ê–õ–Å–ù–ù–û–ï –•–†–ê–ù–ò–õ–ò–©–ï ---${RESET}"
        echo -e " 14. –¢–∏–ø:               ${GRAY}${STORAGE_TYPE_DISP}${RESET}"
        echo -e " 15. URL:               ${GRAY}${REMOTE_STORAGE_URL:-–ù–µ—Ç}${RESET}"
        echo -e " 16. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:      ${GRAY}${MASKED_REMOTE_USER}${RESET}"
        echo -e " 17. –ó–∞–≥—Ä—É–∑–∫–∞:          $ST_REM"
        echo -e " 18. –ù–∞—Å—Ç—Ä–æ–∏—Ç—å / –ü—Ä–æ–≤–µ—Ä–∏—Ç—å"

        echo -e "\n${CYAN}--- –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–¨ ---${RESET}"
        echo -e " 19. –ü–∞—Ä–æ–ª—å —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ${GRAY}${PASS_MASK}${RESET}"
        
        echo -e "\n${CYAN}--- –†–û–¢–ê–¶–ò–Ø –ë–≠–ö–ê–ü–û–í ---${RESET}"
        local DM_DISPLAY="–ü–æ –≤—Ä–µ–º–µ–Ω–∏"; [[ "$DELETE_MODE" == "count" ]] && DM_DISPLAY="–ü–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É"
        echo -e " 20. –†–µ–∂–∏–º —É–¥–∞–ª–µ–Ω–∏—è:    ${GRAY}${DM_DISPLAY}${RESET}"
        echo -e " 21. –°—Ä–æ–∫ —Ö—Ä–∞–Ω–µ–Ω–∏—è:     ${GRAY}${RETENTION_DAYS} –¥–Ω–µ–π${RESET}"
        
        echo -e "\n 0. –ù–∞–∑–∞–¥"
        echo ""
        read -erp "–í—ã–±–æ—Ä: " s
        [[ -z "$s" ]] && return
        
        case $s in
            1) read -erp "–ù–æ–≤—ã–π –ø—É—Ç—å: " np
               if [[ -n "$np" ]]; then 
                   if [[ -d "$np" ]]; then BOT_PATH="$np"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"
                   else print_message "ERROR" "–ü–∞–ø–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!"; fi
               fi ;;
            
            2) 
                scan_system_for_bot
                local def_cont="${FOUND_BOT:-$BOT_CONTAINER_NAME}"
                local prompt_msg="–ò–º—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –±–æ—Ç–∞"
                [[ -n "$FOUND_BOT" ]] && prompt_msg+=" (Enter = '$FOUND_BOT')"
                read -erp "$prompt_msg: " nc; nc="${nc:-$def_cont}"
                if [[ -n "$nc" ]]; then BOT_CONTAINER_NAME="$nc"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"; fi ;;
                
            3) 
                scan_system_for_bot
                local def_db="${FOUND_DB:-$DB_CONTAINER_NAME}"
                local prompt_msg="–ò–º—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –ë–î"
                [[ -n "$FOUND_DB" ]] && prompt_msg+=" (Enter = '$FOUND_DB')"
                read -erp "$prompt_msg: " ndb_c; ndb_c="${ndb_c:-$def_db}"
                if [[ -n "$ndb_c" ]]; then DB_CONTAINER_NAME="$ndb_c"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"; fi ;;

            4) read -erp "–ù–æ–≤—ã–π DB User: " ndb
               if [[ -n "$ndb" ]]; then DB_USER="$ndb"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"; fi ;;
               
            5) read -erp "–ú–∞–∫—Å. –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±—ç–∫–∞–ø–æ–≤: " nd
               if [[ "$nd" =~ ^[0-9]+$ ]]; then MAX_BACKUPS_COUNT="$nd"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"; fi ;;
               
            6) read -erp "–ò—Å–∫–ª—é—á–∏—Ç—å (–Ω–∞–ø—Ä–∏–º–µ—Ä: uploads/cache): " ed
               if [[ -n "$ed" ]]; then 
                   EXCLUDE_DIRS="$ed"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"
               else 
                   if [[ -n "$EXCLUDE_DIRS" ]]; then 
                       read -erp "–û—á–∏—Å—Ç–∏—Ç—å? (y/N): " clr
                       if [[ "$clr" =~ ^[Yy]$ ]]; then EXCLUDE_DIRS=""; save_config; fi
                   fi
               fi ;;
               
            7) read -erp "–ú–∞–∫—Å. —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –≤ MB: " msize
               if [[ "$msize" =~ ^[0-9]+$ ]] && [ "$msize" -gt 0 ]; then 
                   MAX_FILE_SIZE_MB="$msize"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"
               fi ;;
            
            8) read -erp "–ù–æ–≤—ã–π Token: " nt
               if [[ -n "$nt" ]]; then BOT_TOKEN="$nt"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"; fi ;;
               
            9) echo -e "–¢–µ–∫—É—â–∏–π Chat ID: ${CYAN}${CHAT_ID}${RESET}"
               read -erp "–ù–æ–≤—ã–π Chat ID: " nid
               if [[ -n "$nid" ]]; then CHAT_ID="$nid"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"; fi ;;
               
            10) read -erp "–ù–æ–≤—ã–π Thread ID (–ø—É—Å—Ç–æ - —Å–±—Ä–æ—Å–∏—Ç—å): " ntid
                TG_MESSAGE_THREAD_ID="$ntid"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ" ;;
                
            11) # –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
                if [[ "$SEND_TO_TELEGRAM" == "true" ]]; then 
                    SEND_TO_TELEGRAM="false"
                    print_message "INFO" "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è Telegram –æ—Ç–∫–ª—é—á–µ–Ω—ã"
                else 
                    SEND_TO_TELEGRAM="true"
                    print_message "SUCCESS" "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è Telegram –≤–∫–ª—é—á–µ–Ω—ã"
                fi
                save_config ;;
                
            12) # –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–∞–π–ª–∞
                if [[ "$TG_SEND_FILE" == "true" ]]; then
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ
                    if [[ "$REMOTE_STORAGE_TYPE" == "off" || "$SEND_TO_REMOTE" != "true" ]]; then
                        echo ""
                        print_message "WARN" "–£–¥–∞–ª—ë–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ!"
                        print_message "WARN" "–ë—ç–∫–∞–ø—ã –±—É–¥—É—Ç —Ç–æ–ª—å–∫–æ –Ω–∞ –ª–æ–∫–∞–ª—å–Ω–æ–º –¥–∏—Å–∫–µ."
                        read -erp "–í—Å—ë —Ä–∞–≤–Ω–æ –æ—Ç–∫–ª—é—á–∏—Ç—å –æ—Ç–ø—Ä–∞–≤–∫—É —Ñ–∞–π–ª–∞ –≤ TG? (y/N): " confirm
                        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
                            print_message "INFO" "–û—Ç–º–µ–Ω–µ–Ω–æ"
                            sleep 1
                            continue
                        fi
                    fi
                    TG_SEND_FILE="false"
                    print_message "INFO" "–û—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–∞–π–ª–∞ –≤ TG –æ—Ç–∫–ª—é—á–µ–Ω–∞ (—É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã)"
                else
                    TG_SEND_FILE="true"
                    print_message "SUCCESS" "–û—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–∞–π–ª–∞ –≤ TG –≤–∫–ª—é—á–µ–Ω–∞"
                fi
                save_config ;;
                
            13) test_telegram_connection ;;

            14|15|16|18) configure_remote_storage ;;
            
            17) # –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞ —É–¥–∞–ª—ë–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ
                if [[ "$SEND_TO_REMOTE" == "true" ]]; then 
                    SEND_TO_REMOTE="false"
                    print_message "INFO" "–ó–∞–≥—Ä—É–∑–∫–∞ –Ω–∞ —É–¥–∞–ª—ë–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –æ—Ç–∫–ª—é—á–µ–Ω–∞"
                else 
                    if [[ "$REMOTE_STORAGE_TYPE" == "off" ]]; then
                        print_message "WARN" "–°–Ω–∞—á–∞–ª–∞ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ (–ø—É–Ω–∫—Ç 18)"
                        sleep 1.5
                        continue
                    fi
                    SEND_TO_REMOTE="true"
                    print_message "SUCCESS" "–ó–∞–≥—Ä—É–∑–∫–∞ –Ω–∞ —É–¥–∞–ª—ë–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –≤–∫–ª—é—á–µ–Ω–∞"
                fi
                save_config ;;

            19) echo ""
                read -s -erp "–ù–æ–≤—ã–π –ø–∞—Ä–æ–ª—å —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è (–ø—É—Å—Ç–æ - –æ—Ç–∫–ª—é—á–∏—Ç—å): " new_pass
                echo ""
                BACKUP_PASSWORD="$new_pass"
                save_config
                if [[ -n "$new_pass" ]]; then
                    print_message "SUCCESS" "–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –≤–∫–ª—é—á–µ–Ω–æ"
                else
                    print_message "INFO" "–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ"
                fi ;;
                
            20) echo ""
                echo "–†–µ–∂–∏–º —É–¥–∞–ª–µ–Ω–∏—è —Å—Ç–∞—Ä—ã—Ö –±—ç–∫–∞–ø–æ–≤:"
                echo " 1. –ü–æ –≤—Ä–µ–º–µ–Ω–∏ (—Å—Ç–∞—Ä—à–µ N –¥–Ω–µ–π)"
                echo " 2. –ü–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É (–æ—Å—Ç–∞–≤–ª—è—Ç—å N –ø–æ—Å–ª–µ–¥–Ω–∏—Ö)"
                read -erp "–í—ã–±–æ—Ä (1/2): " dm
                if [[ "$dm" == "1" ]]; then DELETE_MODE="time"; elif [[ "$dm" == "2" ]]; then DELETE_MODE="count"; fi
                save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ" ;;
                
            21) read -erp "–°—Ä–æ–∫ —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –¥–Ω—è—Ö: " ndays
                if [[ "$ndays" =~ ^[0-9]+$ ]] && [ "$ndays" -ge 1 ]; then 
                    RETENTION_DAYS="$ndays"; save_config; print_message "SUCCESS" "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ"
                else 
                    print_message "ERROR" "–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ >= 1"
                fi ;;
            
            0) return ;;
        esac
        [[ -n "$s" ]] && sleep 0.5
    done
}

cleanup_old_backups() {
    clear_screen; echo -e "${RED}–û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –±—ç–∫–∞–ø–æ–≤${RESET}"
    
    local del_full=0; local del_db=0; local del_files=0

    echo -e "–¢–µ–∫—É—â–∏–π —Ä–µ–∂–∏–º –æ—á–∏—Å—Ç–∫–∏: ${YELLOW}$DELETE_MODE${RESET}"
    if [[ "$DELETE_MODE" == "count" ]]; then
        echo "–õ–∏–º–∏—Ç —Ö—Ä–∞–Ω–µ–Ω–∏—è: $MAX_BACKUPS_COUNT —à—Ç."
        echo ""
        del_full=$(rotate_backups_by_count "lazarus_full" "–ü–æ–ª–Ω—ã–µ –±—ç–∫–∞–ø—ã" "false" | tail -n1)
        del_db=$(rotate_backups_by_count "lazarus_db" "–ë–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö" "false" | tail -n1)
        del_files=$(rotate_backups_by_count "lazarus_files" "–ê—Ä—Ö–∏–≤—ã —Ñ–∞–π–ª–æ–≤" "false" | tail -n1)
    else
        # time-based
        echo -e " –°—Ä–æ–∫ —Ö—Ä–∞–Ω–µ–Ω–∏—è (–¥–Ω–µ–π): ${YELLOW}$RETENTION_DAYS${RESET}"
        echo ""
        del_full=$(rotate_backups_by_age "lazarus_full" "–ü–æ–ª–Ω—ã–µ –±—ç–∫–∞–ø—ã" "$RETENTION_DAYS" "false" | tail -n1)
        del_db=$(rotate_backups_by_age "lazarus_db" "–ë–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö" "$RETENTION_DAYS" "false" | tail -n1)
        del_files=$(rotate_backups_by_age "lazarus_files" "–ê—Ä—Ö–∏–≤—ã —Ñ–∞–π–ª–æ–≤" "$RETENTION_DAYS" "false" | tail -n1)
    fi

    echo ""
    # normalize empty to 0
    del_full=${del_full:-0}; del_db=${del_db:-0}; del_files=${del_files:-0}
    local total_del=$((del_full + del_db + del_files))

    if [[ "$total_del" -eq 0 ]]; then
        print_message "SUCCESS" "–ß–∏—Å—Ç–∫–∞ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è. –í—Å–µ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –ª–∏–º–∏—Ç–∞."
        read -erp "Enter..." dummy
        return
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        print_message "WARN" "[DRY-RUN] –ö–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –Ω–∞ —É–¥–∞–ª–µ–Ω–∏–µ: $total_del"
    else
        print_message "WARN" "–ë—É–¥–µ—Ç —É–¥–∞–ª–µ–Ω–æ —Å—Ç–∞—Ä—ã—Ö –∞—Ä—Ö–∏–≤–æ–≤: $total_del"
    fi
    # support non-interactive auto-confirm
    if [[ "$AUTO_CONFIRM" == "true" ]]; then
        confirm="y"
    else
        read -erp "–£–¥–∞–ª–∏—Ç—å —ç—Ç–∏ —Ñ–∞–π–ª—ã? (y/N): " confirm
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        # In dry-run we never delete
        log_message "INFO" "[DRY_RUN] Cleanup preview (mode=$DELETE_MODE, retention_days=$RETENTION_DAYS, max_count=$MAX_BACKUPS_COUNT, candidates=$total_del)"
        if [[ "$REPORT_TO_TG" == "true" && "$SEND_TO_TELEGRAM" == "true" ]]; then
            send_telegram_text "$(escape_markdown_v2 "üßπ DRY-RUN –æ—á–∏—Å—Ç–∫–∞: –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤=$total_del, mode=$DELETE_MODE")"
        fi
        read -erp "Enter..." dummy
        return
    fi

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        echo ""
        if [[ "$DELETE_MODE" == "count" ]]; then
            rotate_backups_by_count "lazarus_full" "–ü–æ–ª–Ω—ã–µ –±—ç–∫–∞–ø—ã" "true" >/dev/null
            rotate_backups_by_count "lazarus_db" "–ë–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö" "true" >/dev/null
            rotate_backups_by_count "lazarus_files" "–ê—Ä—Ö–∏–≤—ã —Ñ–∞–π–ª–æ–≤" "true" >/dev/null
        else
            rotate_backups_by_age "lazarus_full" "–ü–æ–ª–Ω—ã–µ –±—ç–∫–∞–ø—ã" "$RETENTION_DAYS" "true" >/dev/null
            rotate_backups_by_age "lazarus_db" "–ë–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö" "$RETENTION_DAYS" "true" >/dev/null
            rotate_backups_by_age "lazarus_files" "–ê—Ä—Ö–∏–≤—ã —Ñ–∞–π–ª–æ–≤" "$RETENTION_DAYS" "true" >/dev/null
        fi
        echo ""; print_message "SUCCESS" "–û—á–∏—Å—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞."
        log_message "INFO" "Cleanup completed (mode=$DELETE_MODE, retention_days=$RETENTION_DAYS, max_count=$MAX_BACKUPS_COUNT, deleted=$total_del)"
        if [[ "$REPORT_TO_TG" == "true" && "$SEND_TO_TELEGRAM" == "true" ]]; then
            send_telegram_text "$(escape_markdown_v2 "üßπ –û—á–∏—Å—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞: —É–¥–∞–ª–µ–Ω–æ=$total_del, mode=$DELETE_MODE")"
        fi
    else
        echo ""; print_message "INFO" "–û—Ç–º–µ–Ω–µ–Ω–æ."
    fi
    read -erp "Enter..." dummy
}

# --- MAIN LOOP ---
rotate_internal_log
check_dependencies
install_script
load_or_create_config
check_config_mismatch # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
# --- Global CLI flags parsing ---
# Support calling like: lazarus --yes --dry-run cleanup
DRY_RUN="false"
REPORT_TO_TG="false"

# Build new argv stripping known global flags
_NEWARGS=()
for _a in "$@"; do
    case "$_a" in
        --yes|-y) AUTO_CONFIRM="true" ;;
        --dry-run|-n) DRY_RUN="true" ;;
        --report-tg) REPORT_TO_TG="true" ;;
        --debug|-d) DEBUG_MODE=true ;;
        *) _NEWARGS+=("$_a") ;;
    esac
done
set -- "${_NEWARGS[@]}"

# Debug mode banner
if [[ "$DEBUG_MODE" == true ]]; then
    echo -e "${MAGENTA}${BOLD}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${RESET}"
    echo -e "${MAGENTA}${BOLD}‚ïë         DEBUG MODE ENABLED            ‚ïë${RESET}"
    echo -e "${MAGENTA}${BOLD}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${RESET}"
    echo -e "${MAGENTA}[DEBUG]${RESET} Version: $VERSION"
    echo -e "${MAGENTA}[DEBUG]${RESET} Config: $CONFIG_FILE"
    echo -e "${MAGENTA}[DEBUG]${RESET} Backup dir: $BACKUP_DIR"
    echo -e "${MAGENTA}[DEBUG]${RESET} Bot path: $BOT_PATH"
    echo -e "${MAGENTA}[DEBUG]${RESET} Containers: $BOT_CONTAINER_NAME / $DB_CONTAINER_NAME"
    echo -e "${MAGENTA}[DEBUG]${RESET} TG: notify=$SEND_TO_TELEGRAM file=$TG_SEND_FILE"
    echo -e "${MAGENTA}[DEBUG]${RESET} Remote: $REMOTE_STORAGE_TYPE ($SEND_TO_REMOTE)"
    echo ""
fi

case "$1" in
    backup_full) create_backup "full" ;;
    backup_db)   create_backup "db_only" ;;
    backup_files) create_backup "files_only" ;;
    cleanup|cleanup_old_backups)
        cleanup_old_backups ;;
    restore) menu_restore ;;
    check_update) check_for_updates ;;
    *)
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è cron –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞
        check_cron_mismatch
        
        while true; do
            # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ —Å—Ç–∞—Ç—É—Å—ã –∏–∑ cron
            CRON_STATUS_FULL=$(get_cron_status "full")
            CRON_STATUS_DB=$(get_cron_status "db")
            CRON_STATUS_FILES=$(get_cron_status "files")
            
            # –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –±—ç–∫–∞–ø–æ–≤
            get_backup_stats
            
            # –¶–≤–µ—Ç–æ–≤–∞—è –∏–Ω–¥–∏–∫–∞—Ü–∏—è —Å—Ç–∞—Ç—É—Å–æ–≤ cron
            # Full –∏ DB ‚Äî –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ (–∫—Ä–∞—Å–Ω—ã–µ –µ—Å–ª–∏ –≤—ã–∫–ª—é—á–µ–Ω—ã –æ–±–∞), Files ‚Äî –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π (—Å–µ—Ä—ã–π –µ—Å–ª–∏ –≤—ã–∫–ª—é—á–µ–Ω)
            NO_CRITICAL_BACKUP=false
            [[ "$CRON_STATUS_FULL" == "–í—ã–∫–ª" && "$CRON_STATUS_DB" == "–í—ã–∫–ª" ]] && NO_CRITICAL_BACKUP=true
            
            COLOR_FULL="$GRAY"; [[ "$CRON_STATUS_FULL" != "–í—ã–∫–ª" ]] && COLOR_FULL="$YELLOW"
            COLOR_DB="$GRAY"; [[ "$CRON_STATUS_DB" != "–í—ã–∫–ª" ]] && COLOR_DB="$YELLOW"
            COLOR_FILES="$GRAY"; [[ "$CRON_STATUS_FILES" != "–í—ã–∫–ª" ]] && COLOR_FILES="$YELLOW"
            
            BOT_VERSION=$(get_bot_version_display)
            CONTAINER_STATUS=$(get_container_status)
            
            # –¶–≤–µ—Ç —Å—Ç–∞—Ç—É—Å–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
            STATUS_COLOR="$GREEN"
            [[ "$CONTAINER_STATUS" != "Online" ]] && STATUS_COLOR="$RED"
            
            clear_screen
            echo -e "${GREEN}${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${RESET}"
            echo -e "${GREEN}${BOLD}  LAZARUS Backup Manager v${VERSION}${RESET}"
            echo -e "${GREEN}${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${RESET}"
            echo -e "–ë–æ—Ç: ${CYAN}${BOT_VERSION}${RESET} | –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä: ${STATUS_COLOR}${CONTAINER_STATUS}${RESET}"
            echo ""
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±—ç–∫–∞–ø–æ–≤
            echo -e "–ë—ç–∫–∞–ø—ã: ${STATS_FULL} Full | ${STATS_DB} DB | ${STATS_FILES} Files | ${BOLD}${STATS_SIZE}${RESET} –≤—Å–µ–≥–æ"
            if [[ -n "$STATS_LAST" ]]; then
                echo -e "–ü–æ—Å–ª–µ–¥–Ω–∏–π: ${STATS_LAST} (${STATS_LAST_AGO})"
            fi
            echo ""
            
            # –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –µ—Å–ª–∏ –Ω–µ—Ç –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –∞–≤—Ç–æ-–±—ç–∫–∞–ø–æ–≤
            if [[ "$NO_CRITICAL_BACKUP" == true ]]; then
                echo -e "${RED}${BOLD}‚ö†Ô∏è  –í–ù–ò–ú–ê–ù–ò–ï: –ê–≤—Ç–æ-–±—ç–∫–∞–ø –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω!${RESET}"
                echo -e "${RED}   –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –≤–∫–ª—é—á–∏—Ç—å Full –∏–ª–∏ DB –±—ç–∫–∞–ø${RESET}"
                echo ""
            fi
            
            echo -e "–ê–≤—Ç–æ-–±—ç–∫–∞–ø (cron):"
            echo -e " ‚Ä¢ Full:  ${COLOR_FULL}${CRON_STATUS_FULL}${RESET}"
            echo -e " ‚Ä¢ DB:    ${COLOR_DB}${CRON_STATUS_DB}${RESET}"
            echo -e " ‚Ä¢ Files: ${COLOR_FILES}${CRON_STATUS_FILES}${RESET}"
            echo ""
            echo " --- –î–ï–ô–°–¢–í–ò–Ø ---"
            echo " 1. –†—É—á–Ω–æ–π –±–µ–∫–∞–ø (Full / DB / Files)"
            echo " 2. –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –∞–≤—Ç–æ-–±–µ–∫–∞–ø"
            echo " 3. –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∏–∑ –±—ç–∫–∞–ø–∞"
            echo " 4. –ù–∞—Å—Ç—Ä–æ–π–∫–∏ (–ü—É—Ç–∏ / –¢–æ–∫–µ–Ω—ã / –†–æ—Ç–∞—Ü–∏—è)"
            
            CLEANUP_LABEL=""
            if [[ "$DELETE_MODE" == "time" ]]; then
                CLEANUP_LABEL="(>$RETENTION_DAYS –¥–Ω–µ–π)"
            else
                CLEANUP_LABEL="(>$MAX_BACKUPS_COUNT —à—Ç.)"
            fi
            echo " 5. –£–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä—ã–µ –±—ç–∫–∞–ø—ã $CLEANUP_LABEL"
            echo ""
            echo -e " 8. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è"
            echo -e "${RED} 666. –£–¥–∞–ª–∏—Ç—å —Å–∫—Ä–∏–ø—Ç (Uninstall)${RESET}"
            echo " 0. –í—ã—Ö–æ–¥"
            echo ""
            read -erp "–í—ã–±–æ—Ä (Enter - –≤—ã—Ö–æ–¥): " opt; [[ -z "$opt" ]] && exit 0
            case $opt in
                1) menu_manual_backup ;; 2) menu_automation ;; 3) menu_restore ;; 
                4) menu_settings ;; 5) cleanup_old_backups ;; 8) check_for_updates ;; 666) uninstall_script ;; 0) exit 0 ;;
            esac
        done
        ;;
esac
